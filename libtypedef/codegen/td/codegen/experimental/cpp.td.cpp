
#include "td/codegen/experimental/cpp.td.h"

// Generated by the Typedef compiler (EXPERIMENTAL)



namespace {

template <typename T>
inline bool IsEmpty(const td::Vector<T>& v) {
  return v.size() == 0;
}


inline std::string escape_json(const std::string& s) {
  std::ostringstream o;
  for (auto c = s.cbegin(); c != s.cend(); c++) {
    switch (*c) {
      case '"': o << "\\\""; break;
      case '\\': o << "\\\\"; break;
      case '\b': o << "\\b"; break;
      case '\f': o << "\\f"; break;
      case '\n': o << "\\n"; break;
      case '\r': o << "\\r"; break;
      case '\t': o << "\\t"; break;
      default:
        if ('\x00' <= *c && *c <= '\x1f') {
          o << "\\u" << std::hex << std::setw(4) << std::setfill('0')
            << static_cast<int>(*c);
        } else {
          o << *c;
        }
    }
  }
  return o.str();
}

inline std::string char32ToJsonString(char32_t c) {
  std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> converter;
  std::string utf8 = converter.to_bytes(&c, &c + 1);
  return escape_json(utf8);
}

inline char32_t GetCharValue(std::string_view str) {
  if (str.size() == 2 && str[0] == '\\') {
    switch (str[1]) {
      case 'n':
        return U'\n';
      case 'r':
        return U'\r';
      case 't':
        return U'\t';
      case '\\':
        return U'\\';
      case '0':
        return U'\0';
      case '\'':
        return U'\'';
      case '\"':
        return U'\"';
    }
  }
  if (str.size() == 4 && str[0] == '\\' && str[1] == 'x') {
    // TODO this seems rather inefficient, do something better?
    std::istringstream ss(std::string(str.substr(2)));
    int value;
    ss >> std::hex >> value;
    return static_cast<char32_t>(value);
  }

  if (str.size() >= 3 && str.size() <= 10 && str[0] == '\\' && str[1] == 'u' &&
      str[2] == '{' && str.back() == '}') {
    // TODO this seems rather inefficient, do something better?
    std::istringstream ss(std::string(str.substr(3, str.size() - 4)));
    int value;
    ss >> std::hex >> value;
    return static_cast<char32_t>(value);
  }

  if (str.size() > 0) {
    std::string inner_str(str);
    std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> converter;
    std::u32string str32 = converter.from_bytes(inner_str);
    if (str32.size() == 1) {
      return str32[0];
    }
  }
  throw std::runtime_error("Invalid char.");
}

// Struct and variant JSON forward declarations

// Struct and variant JSON definitions

}

namespace td {
namespace codegen {
namespace experimental {
namespace cpp {

// Struct and variant definitions

// td::codegen::experimental::cpp::TdType member definitions

// AccessInfo member definitions

// StructDecl member definitions

// td::codegen::experimental::cpp::UserTypeDeclaration member definitions

// TmplValueDereference member definitions

// TmplFuncCall member definitions

// td::codegen::experimental::cpp::TmplExpression member definitions

// TmplIf member definitions

// TmplIfBlock member definitions

// TmplForBlock member definitions

// SwitchCase member definitions

// SwitchBlock member definitions

// td::codegen::experimental::cpp::TmplItem member definitions

// TmplFunction member definitions

// Options member definitions

// CppData member definitions

// Struct and variant JSON declarations






































































// Tmplate function definitions

void TmplStructDeclaration(std::ostream& os, const StructDecl& s, const Options& opt) {
os << "\n// ";
QualifiedName(os, s.nqn());
os << " struct declaration.\nclass ";
os << s.identifier();
os << " {\n public:\n  // Nested type declarations\n  ";
VecUserTypeDeclarationT(os, s.nested_type_decls(), opt);
os << "\n  // Inline type declarations\n  ";
VecUserTypeDeclarationT(os, s.inline_type_decls(), opt);
os << "\n\n  ";
os << s.identifier();
os << "() {}\n  ~";
os << s.identifier();
os << "() {}\n\n  ";
os << s.identifier();
os << "(const ";
os << s.identifier();
os << "&) = delete;\n  ";
os << s.identifier();
os << "& operator=(const ";
os << s.identifier();
os << "&) = delete;\n  ";
os << s.identifier();
os << "(";
os << s.identifier();
os << "&&) = default;\n  ";
os << s.identifier();
os << "& operator=(";
os << s.identifier();
os << "&&) = default;\n\n  ";
if (opt.generate_json_parser()) {
os << "\n  static ";
os << s.identifier();
os << " FromJson(const std::string& str);\n  ";
} else {
}
os << "\n\n  ";


for (size_t td_iter_ = 0; td_iter_ < s.fields().size(); td_iter_++) {
  auto& field = s.fields()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.fields().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "\n  ";
// Switch field.access_by()

if (field.access_by().is_value()) {
os << "\n  ";
CppType(os, field);
os << " get_";
os << field.identifier();
os << "() const {\n    return ";
os << field.identifier();
os << "_;\n  }\n  void set_";
os << field.identifier();
os << "(";
CppType(os, field);
os << " val) {\n    ";
os << field.identifier();
os << "_ = val;\n  }\n  ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() {\n    return ";
os << field.identifier();
os << "_;\n  }\n  const ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() const {\n    return ";
os << field.identifier();
os << "_;\n  }\n  ";
} else 
if (field.access_by().is_reference()) {
os << "\n  void set_";
os << field.identifier();
os << "(";
CppType(os, field);
os << "&& val) {\n    ";
os << field.identifier();
os << "_ = std::move(val);\n  }\n  ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() {\n    return ";
os << field.identifier();
os << "_;\n  }\n  const ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() const {\n    return ";
os << field.identifier();
os << "_;\n  }\n  ";
} else 
if (field.access_by().is_pointer()) {
os << "\n  bool has_";
os << field.identifier();
os << "() const {\n    return ";
os << field.identifier();
os << "_.operator bool();\n  }\n  void alloc_";
os << field.identifier();
os << "() {\n    ";
os << field.identifier();
os << "_ = std::make_unique<";
CppType(os, field);
os << ">();\n  }\n  void delete_";
os << field.identifier();
os << "() {\n    return ";
os << field.identifier();
os << "_.reset(nullptr);\n  }\n  void set_";
os << field.identifier();
os << "(std::unique_ptr<";
CppType(os, field);
os << "> val) {\n    ";
os << field.identifier();
os << "_ = std::move(val);\n  }\n  void set_";
os << field.identifier();
os << "(";
CppType(os, field);
os << "* val) {\n    ";
os << field.identifier();
os << "_.reset(std::move(val));\n  }\n  ";
CppType(os, field);
os << "* ptr_";
os << field.identifier();
os << "() {\n    #if TD_AUTO_ALLOC\n    if (!has_";
os << field.identifier();
os << "()) {\n      alloc_";
os << field.identifier();
os << "();\n    }\n    #endif\n    #ifdef DEBUG\n    if (!has_";
os << field.identifier();
os << "()) {\n      TD_THROW(\"Attempted null reference\");\n    }\n    #endif\n    return ";
os << field.identifier();
os << "_.get();\n  }\n  ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() {\n    return *ptr_";
os << field.identifier();
os << "();\n  }\n  const ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() const {\n    #ifdef DEBUG\n    if (!has_";
os << field.identifier();
os << "()) {\n      TD_THROW(\"Attempted null reference\");\n    }\n    #endif\n    return *";
os << field.identifier();
os << "_.get();\n  }\n  ";
} else  {
}
os << "\n  ";
}

os << "\n\n private:\n  ";


for (size_t td_iter_ = 0; td_iter_ < s.fields().size(); td_iter_++) {
  auto& field = s.fields()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.fields().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch field.access_by()

if (field.access_by().is_pointer()) {
os << "std::unique_ptr<";
CppType(os, field);
os << "> ";
os << field.identifier();
os << "_;";
} else 
if (field.access_by().is_value()) {
CppType(os, field);
os << " ";
os << field.identifier();
os << "_ = 0;";
} else  {
CppType(os, field);
os << " ";
os << field.identifier();
os << "_;";
}
os << "\n  ";
}

os << "\n}; // class ";
os << s.identifier();
os << "\n";

}
std::string TmplStructDeclaration(const StructDecl& s, const Options& opt) {
  std::stringstream oss;
  TmplStructDeclaration(oss, s, opt);
  return oss.str();
}
void TmplStructDefinition(std::ostream& os, const StructDecl& s, const Options& opt) {
os << "\n// ";
QualifiedName(os, s.nqn());
os << " member definitions\n";

}
std::string TmplStructDefinition(const StructDecl& s, const Options& opt) {
  std::stringstream oss;
  TmplStructDefinition(oss, s, opt);
  return oss.str();
}
void TmplVariantDeclaration(std::ostream& os, const StructDecl& v, const Options& opt) {
os << "\n// ";
QualifiedName(os, v.fqn());
os << " variant declaration.\nclass ";
os << v.identifier();
os << " {\n public:\n  // Nested type declarations\n  ";
VecUserTypeDeclarationT(os, v.nested_type_decls(), opt);
os << "\n  // Inline type declarations\n  ";
VecUserTypeDeclarationT(os, v.inline_type_decls(), opt);
os << "\n\n  ";
os << v.identifier();
os << "() {}\n  ~";
os << v.identifier();
os << "() {\n    tag = Tag::__TAG__UNSET;\n  }\n\n  ";
os << v.identifier();
os << "(const ";
os << v.identifier();
os << "&) = delete;\n  ";
os << v.identifier();
os << "& operator=(const ";
os << v.identifier();
os << "&) = delete;\n  ";
os << v.identifier();
os << "(";
os << v.identifier();
os << "&&) = default;\n  ";
os << v.identifier();
os << "& operator=(";
os << v.identifier();
os << "&&) = default;\n\n  ";
if (opt.generate_json_parser()) {
os << "\n  static ";
os << v.identifier();
os << " FromJson(const std::string& str);\n  ";
} else {
}
os << "\n\n  enum class Tag {\n    __TAG__UNSET = 0,\n    ";


for (size_t td_iter_ = 0; td_iter_ < v.fields().size(); td_iter_++) {
  auto& field = v.fields()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == v.fields().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "TAG_";
os << field.identifier();
os << " = ";
Index1(os);
os << ",\n    ";
}

os << "\n  };\n  Tag Which() const { return tag; }\n\n  ";


for (size_t td_iter_ = 0; td_iter_ < v.fields().size(); td_iter_++) {
  auto& field = v.fields()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == v.fields().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "\n  bool is_";
os << field.identifier();
os << "() const {\n    return val_.index() == ";
Index1(os);
os << ";\n  }\n  ";
// Switch field.access_by()

if (field.access_by().is_value()) {
os << "\n  ";
CppType(os, field);
os << " get_";
os << field.identifier();
os << "() const {\n    return std::get<";
Index1(os);
os << ">(val_);\n  }\n  void set_";
os << field.identifier();
os << "(";
CppType(os, field);
os << " val) {\n    tag = Tag::TAG_";
os << field.identifier();
os << ";\n    val_.emplace<";
Index1(os);
os << ">(val);\n  }\n  ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() {\n    if (!is_";
os << field.identifier();
os << "()) {\n      tag = Tag::TAG_";
os << field.identifier();
os << ";\n      val_.emplace<";
Index1(os);
os << ">();\n    }\n    return std::get<";
Index1(os);
os << ">(val_);\n  }\n  const ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() const {\n    return std::get<";
Index1(os);
os << ">(val_);\n  }\n  ";
} else 
if (field.access_by().is_reference()) {
os << "\n  ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() {\n    if (!is_";
os << field.identifier();
os << "()) {\n      tag = Tag::TAG_";
os << field.identifier();
os << ";\n      val_.emplace<";
Index1(os);
os << ">();\n    }\n    return std::get<";
Index1(os);
os << ">(val_);\n  }\n  const ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() const {\n    return std::get<";
Index1(os);
os << ">(val_);\n  }\n  void set_";
os << field.identifier();
os << "(";
CppType(os, field);
os << "&& val) {\n    tag = Tag::TAG_";
os << field.identifier();
os << ";\n    val_.emplace<";
Index1(os);
os << ">(std::move(val));\n  }\n  ";
} else 
if (field.access_by().is_pointer()) {
os << "\n  bool has_";
os << field.identifier();
os << "() const {\n    return is_";
os << field.identifier();
os << "() && std::get<";
Index1(os);
os << ">(val_).operator bool();\n  }\n  void alloc_";
os << field.identifier();
os << "() {\n    tag = Tag::TAG_";
os << field.identifier();
os << ";\n    val_.emplace<";
Index1(os);
os << ">(std::make_unique<";
CppType(os, field);
os << ">());\n  }\n  void delete_";
os << field.identifier();
os << "() {\n    return std::get<";
Index1(os);
os << ">(val_).reset(nullptr);\n  }\n  void set_";
os << field.identifier();
os << "(std::unique_ptr<";
CppType(os, field);
os << "> val) {\n    tag = Tag::TAG_";
os << field.identifier();
os << ";\n    val_.emplace<";
Index1(os);
os << ">(std::move(val));\n  }\n  void set_";
os << field.identifier();
os << "(";
CppType(os, field);
os << "* val) {\n    tag = Tag::TAG_";
os << field.identifier();
os << ";\n    std::get<";
Index1(os);
os << ">(val_).reset(std::move(val));\n  }\n  ";
CppType(os, field);
os << "* ptr_";
os << field.identifier();
os << "() {\n    #if TD_AUTO_ALLOC\n    if (!has_";
os << field.identifier();
os << "()) {\n      alloc_";
os << field.identifier();
os << "();\n    }\n    #endif\n    return std::get<";
Index1(os);
os << ">(val_).get();\n  }\n  ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() {\n    return *ptr_";
os << field.identifier();
os << "();\n  }\n  const ";
CppType(os, field);
os << "& ";
os << field.identifier();
os << "() const {\n    return *std::get<";
Index1(os);
os << ">(val_).get();\n  }\n  ";
} else  {
}
}

os << "\n\n private:\n  Tag tag = Tag::__TAG__UNSET;\n\n  std::variant<\n    std::monostate\n  ";


for (size_t td_iter_ = 0; td_iter_ < v.fields().size(); td_iter_++) {
  auto& field = v.fields()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == v.fields().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch field.access_by()

if (field.access_by().is_pointer()) {
os << ", std::unique_ptr<";
CppType(os, field);
os << ">";
} else  {
os << ", ";
CppType(os, field);
}
os << "\n  ";
}

os << "\n  > val_;\n\n};  // class ";
os << v.identifier();
os << "\n";

}
std::string TmplVariantDeclaration(const StructDecl& v, const Options& opt) {
  std::stringstream oss;
  TmplVariantDeclaration(oss, v, opt);
  return oss.str();
}
void TmplVariantDefinition(std::ostream& os, const StructDecl& v, const Options& opt) {
os << "\n// ";
QualifiedName(os, v.fqn());
os << " member definitions\n";

}
std::string TmplVariantDefinition(const StructDecl& v, const Options& opt) {
  std::stringstream oss;
  TmplVariantDefinition(oss, v, opt);
  return oss.str();
}
void CppHeader(std::ostream& os, const CppData& d, const Options& opt) {
os << "\n#ifndef ";
os << d.header_guard();
os << "\n#define ";
os << d.header_guard();
os << "\n\n#include <cstdint>\n#include <memory>\n#include <string>\n#include <variant>\n#include <ostream>\n\n#include <typedef/builtin_types.h>\n\n// Generated by the Typedef compiler (EXPERIMENTAL)\n\n#ifndef TD_THROW\n#define TD_STRINGIZE_DETAIL(x) #x\n#define TD_STRINGIZE(x) TD_STRINGIZE_DETAIL(x)\n#define TD_THROW(msg) (throw msg __FILE__ \":\" TD_STRINGIZE(__LINE__))\n#endif\n\n#ifndef TD_AUTO_ALLOC\n#define TD_AUTO_ALLOC 1\n#endif\n\n";


for (size_t td_iter_ = 0; td_iter_ < d.namespaces().size(); td_iter_++) {
  auto& ns = d.namespaces()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.namespaces().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "namespace ";
os << ns;
os << " {\n";
}

os << "\n// Forward declarations.\n";


for (size_t td_iter_ = 0; td_iter_ < d.user_type_decls().size(); td_iter_++) {
  auto& type_decl = d.user_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.user_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch type_decl

if (type_decl.is_struct_decl()) {
os << "class ";
os << type_decl.struct_decl().identifier();
os << ";";
} else 
if (type_decl.is_variant_decl()) {
os << "class ";
os << type_decl.variant_decl().identifier();
os << ";";
} else  {
}
os << "\n";
}

os << "\n// Struct and variant declarations\n";


for (size_t td_iter_ = 0; td_iter_ < d.user_type_decls().size(); td_iter_++) {
  auto& type_decl = d.user_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.user_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch type_decl

if (type_decl.is_struct_decl()) {
TmplStructDeclaration(os, type_decl.struct_decl(), opt);
} else 
if (type_decl.is_variant_decl()) {
TmplVariantDeclaration(os, type_decl.variant_decl(), opt);
} else  {
}
os << "\n";
}

os << "\n// Struct and variant JSON declarations\n";


for (size_t td_iter_ = 0; td_iter_ < d.user_type_decls().size(); td_iter_++) {
  auto& type_decl = d.user_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.user_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch type_decl

if (type_decl.is_struct_decl()) {
JsonDeclarations(os, type_decl.struct_decl(), opt);
} else 
if (type_decl.is_variant_decl()) {
JsonDeclarations(os, type_decl.variant_decl(), opt);
} else  {
}
os << "\n";
}

os << "\n\n// Tmplate function declarations\n";


for (size_t td_iter_ = 0; td_iter_ < d.tmpl_funcs().size(); td_iter_++) {
  auto& tmpl_func = d.tmpl_funcs()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.tmpl_funcs().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
TmplFuncDeclaration(os, tmpl_func);
}

os << "\n\n";


for (size_t td_iter_ = 0; td_iter_ < d.namespaces().size(); td_iter_++) {
  auto& ns = d.namespaces()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.namespaces().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "} // namespace ";
os << ns;
os << "\n";
}

os << "\n\n#endif  // ";
os << d.header_guard();
os << "\n";

}
std::string CppHeader(const CppData& d, const Options& opt) {
  std::stringstream oss;
  CppHeader(oss, d, opt);
  return oss.str();
}
void CppSrcJsonWriterHelpers(std::ostream& os) {
os << "\ninline std::string escape_json(const std::string& s) {\n  std::ostringstream o;\n  for (auto c = s.cbegin(); c != s.cend(); c++) {\n    switch (*c) {\n      case '\"': o << \"\\\\\\\"\"; break;\n      case '\\\\': o << \"\\\\\\\\\"; break;\n      case '\\b': o << \"\\\\b\"; break;\n      case '\\f': o << \"\\\\f\"; break;\n      case '\\n': o << \"\\\\n\"; break;\n      case '\\r': o << \"\\\\r\"; break;\n      case '\\t': o << \"\\\\t\"; break;\n      default:\n        if ('\\x00' <= *c && *c <= '\\x1f') {\n          o << \"\\\\u\" << std::hex << std::setw(4) << std::setfill('0')\n            << static_cast<int>(*c);\n        } else {\n          o << *c;\n        }\n    }\n  }\n  return o.str();\n}\n\ninline std::string char32ToJsonString(char32_t c) {\n  std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> converter;\n  std::string utf8 = converter.to_bytes(&c, &c + 1);\n  return escape_json(utf8);\n}\n\n// This is a very inefficint way of doing this, but\n// C++17 standard libs don't give us great options.\n// TODO: Also it may not work in C++20?\nstd::u32string decode_utf8(const std::string& utf8_string) {\n  struct destructible_codecvt : public std::codecvt<char32_t, char, std::mbstate_t> {\n    using std::codecvt<char32_t, char, std::mbstate_t>::codecvt;\n    ~destructible_codecvt() = default;\n  };\n  std::wstring_convert<destructible_codecvt, char32_t> utf32_converter;\n  return utf32_converter.from_bytes(utf8_string);\n}\n\ninline char32_t GetCharValue(std::string_view str) {\n  if (str.size() == 2 && str[0] == '\\\\') {\n    switch (str[1]) {\n      case 'n':\n        return U'\\n';\n      case 'r':\n        return U'\\r';\n      case 't':\n        return U'\\t';\n      case '\\\\':\n        return U'\\\\';\n      case '0':\n        return U'\\0';\n      case '\\'':\n        return U'\\'';\n      case '\\\"':\n        return U'\\\"';\n    }\n  }\n  if (str.size() == 4 && str[0] == '\\\\' && str[1] == 'x') {\n    // TODO this seems rather inefficient, do something better?\n    std::istringstream ss(std::string(str.substr(2)));\n    int value;\n    ss >> std::hex >> value;\n    return static_cast<char32_t>(value);\n  }\n\n  if (str.size() >= 3 && str.size() <= 10 && str[0] == '\\\\' && str[1] == 'u' &&\n      str[2] == '{' && str.back() == '}') {\n    // TODO this seems rather inefficient, do something better?\n    std::istringstream ss(std::string(str.substr(3, str.size() - 4)));\n    int value;\n    ss >> std::hex >> value;\n    return static_cast<char32_t>(value);\n  }\n\n  if (str.size() > 0) {\n    std::string inner_str(str);\n    std::u32string str32 = decode_utf8(inner_str);\n    if (str32.size() == 1) {\n      return str32[0];\n    }\n  }\n  throw std::runtime_error(\"JSON format error: expected 'char'.\");\n}\n";

}
std::string CppSrcJsonWriterHelpers() {
  std::stringstream oss;
  CppSrcJsonWriterHelpers(oss);
  return oss.str();
}
void CppSrcJsonParserHelpers(std::ostream& os) {
os << "\nbool JsonParseBool(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsBool()) {\n    return val.GetBool();\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'bool'.\");\n  }\n}\nchar32_t JsonParseChar(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsString()) {\n    std::string str(val.GetString(), val.GetStringLength());\n    return GetCharValue(str);\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'string'.\");\n  }\n}\nstd::string JsonParseStr(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsString()) {\n    return val.GetString();\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'string'.\");\n  }\n}\nfloat JsonParseF32(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsDouble()) {\n    return (float)val.GetDouble();\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'float'.\");\n  }\n}\ndouble JsonParseF64(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsDouble()) {\n    return val.GetDouble();\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'double'.\");\n  }\n}\nstd::uint8_t JsonParseU8(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsUint()) {\n    unsigned int ui = val.GetUint();\n    if (ui > std::numeric_limits<std::uint8_t>::max() ||\n        ui < std::numeric_limits<std::uint8_t>::min()) {\n      throw std::runtime_error(\"JSON format error: unsigned integer '\" +\n                               std::to_string(ui) +\n                               \"' exceeded 'u8' capacity.\");\n    }\n    return (std::uint8_t)ui;\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'unsigned integer'.\");\n  }\n}\nstd::uint16_t JsonParseU16(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsUint()) {\n    unsigned int ui = val.GetUint();\n    if (ui > std::numeric_limits<std::uint16_t>::max() ||\n        ui < std::numeric_limits<std::uint16_t>::min()) {\n      throw std::runtime_error(\"JSON format error: unsigned integer '\" +\n                               std::to_string(ui) +\n                               \"' exceeded 'u16' capacity.\");\n    }\n    return (std::uint16_t)ui;\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'unsigned integer'.\");\n  }\n}\nstd::uint32_t JsonParseU32(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsUint()) {\n    return val.GetUint();\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'unsigned integer'.\");\n  }\n}\nstd::uint64_t JsonParseU64(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsUint64()) {\n    return val.GetUint64();\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'unsigned integer'.\");\n  }\n}\nstd::int8_t JsonParseI8(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsInt()) {\n    int ui = val.GetInt();\n    if (ui > std::numeric_limits<std::int8_t>::max() ||\n        ui < std::numeric_limits<std::int8_t>::min()) {\n      throw std::runtime_error(\"JSON format error: integer '\" +\n                               std::to_string(ui) +\n                               \"' exceeded 'i8' capacity.\");\n    }\n    return (std::int8_t)ui;\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'integer'.\");\n  }\n}\nstd::int16_t JsonParseI16(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsInt()) {\n    int ui = val.GetInt();\n    if (ui > std::numeric_limits<std::int16_t>::max() ||\n        ui < std::numeric_limits<std::int16_t>::min()) {\n      throw std::runtime_error(\"JSON format error: integer '\" +\n                               std::to_string(ui) +\n                               \"' exceeded 'i16' capacity.\");\n    }\n    return (std::int16_t)ui;\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'integer'.\");\n  }\n}\nstd::int32_t JsonParseI32(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsInt()) {\n    return val.GetInt();\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'integer'.\");\n  }\n}\nstd::int64_t JsonParseI64(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {\n  if (val.IsInt64()) {\n    return val.GetInt64();\n  } else {\n    throw std::runtime_error(\"JSON format error: expected 'integer'.\");\n  }\n}\n";

}
std::string CppSrcJsonParserHelpers() {
  std::stringstream oss;
  CppSrcJsonParserHelpers(oss);
  return oss.str();
}
void CppSrcHelpers(std::ostream& os) {
os << "\ntemplate <typename T>\ninline bool IsEmpty(const td::Vector<T>& v) {\n  return v.size() == 0;\n}\n";

}
std::string CppSrcHelpers() {
  std::stringstream oss;
  CppSrcHelpers(oss);
  return oss.str();
}
void CppSource(std::ostream& os, const CppData& d, const Options& opt) {
os << "\n#include \"";
os << d.header_filename();
os << "\"\n\n// Generated by the Typedef compiler (EXPERIMENTAL)\n\n";
if (opt.generate_json_parser()) {
os << "#include \"rapidjson/document.h\"\n";
} else {
}
os << "\n\nnamespace {\n";
CppSrcHelpers(os);
os << "\n";
if (opt.generate_json_writer()) {
CppSrcJsonWriterHelpers(os);
} else {
}
os << "\n";
if (opt.generate_json_parser()) {
CppSrcJsonParserHelpers(os);
} else {
}
os << "\n// Struct and variant JSON forward declarations\n";


for (size_t td_iter_ = 0; td_iter_ < d.user_type_decls().size(); td_iter_++) {
  auto& type_decl = d.user_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.user_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch type_decl

if (type_decl.is_struct_decl()) {
JsonSrcForwardDeclarations(os, type_decl.struct_decl(), opt);
} else 
if (type_decl.is_variant_decl()) {
JsonSrcForwardDeclarations(os, type_decl.variant_decl(), opt);
} else  {
}
}

os << "\n// Struct and variant JSON definitions\n";


for (size_t td_iter_ = 0; td_iter_ < d.user_type_decls().size(); td_iter_++) {
  auto& type_decl = d.user_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.user_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch type_decl

if (type_decl.is_struct_decl()) {
JsonSrcDefinitions(os, type_decl.struct_decl(), opt);
} else 
if (type_decl.is_variant_decl()) {
JsonSrcDefinitions(os, type_decl.variant_decl(), opt);
} else  {
}
}

os << "\n}\n\n";


for (size_t td_iter_ = 0; td_iter_ < d.namespaces().size(); td_iter_++) {
  auto& ns = d.namespaces()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.namespaces().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "namespace ";
os << ns;
os << " {\n";
}

os << "\n// Struct and variant definitions\n";


for (size_t td_iter_ = 0; td_iter_ < d.user_type_decls().size(); td_iter_++) {
  auto& type_decl = d.user_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.user_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch type_decl

if (type_decl.is_struct_decl()) {
TmplStructDefinition(os, type_decl.struct_decl(), opt);
} else 
if (type_decl.is_variant_decl()) {
TmplVariantDefinition(os, type_decl.variant_decl(), opt);
} else  {
}
}

os << "\n// Struct and variant JSON declarations\n";


for (size_t td_iter_ = 0; td_iter_ < d.user_type_decls().size(); td_iter_++) {
  auto& type_decl = d.user_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.user_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch type_decl

if (type_decl.is_struct_decl()) {
JsonStructDefinitions(os, type_decl.struct_decl(), opt);
} else 
if (type_decl.is_variant_decl()) {
JsonVariantDefinitions(os, type_decl.variant_decl(), opt);
} else  {
}
}

os << "\n// Tmplate function definitions\n";


for (size_t td_iter_ = 0; td_iter_ < d.tmpl_funcs().size(); td_iter_++) {
  auto& tmpl_func = d.tmpl_funcs()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.tmpl_funcs().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
TmplFuncDefinition(os, tmpl_func);
}

os << "\n\n";


for (size_t td_iter_ = 0; td_iter_ < d.namespaces().size(); td_iter_++) {
  auto& ns = d.namespaces()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == d.namespaces().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "} // namespace ";
os << ns;
os << "\n";
}

os << "\n";

}
std::string CppSource(const CppData& d, const Options& opt) {
  std::stringstream oss;
  CppSource(oss, d, opt);
  return oss.str();
}
void VecUserTypeDeclarationT(std::ostream& os, const td::Vector<UserTypeDeclaration>& ut, const Options& opt) {


for (size_t td_iter_ = 0; td_iter_ < ut.size(); td_iter_++) {
  auto& n = ut[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == ut.size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "\n";
// Switch n

if (n.is_struct_decl()) {
TmplStructDeclaration(os, n.struct_decl(), opt);
} else 
if (n.is_variant_decl()) {
TmplVariantDeclaration(os, n.variant_decl(), opt);
} else  {
}
os << "\n";
}


}
std::string VecUserTypeDeclarationT(const td::Vector<UserTypeDeclaration>& ut, const Options& opt) {
  std::stringstream oss;
  VecUserTypeDeclarationT(oss, ut, opt);
  return oss.str();
}
void CppType(std::ostream& os, const AccessInfo& a) {
os << a.cpp_type();
if (!IsEmpty(a.type_arguments())) {
os << "<";


for (size_t td_iter_ = 0; td_iter_ < a.type_arguments().size(); td_iter_++) {
  auto& arg = a.type_arguments()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == a.type_arguments().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
CppType(os, arg);
if (!IsLast()) {
os << ", ";
} else {
}
}

os << ">";
} else {
}

}
std::string CppType(const AccessInfo& a) {
  std::stringstream oss;
  CppType(oss, a);
  return oss.str();
}
void QualifiedName(std::ostream& os, const td::Vector<std::string>& fqn) {


for (size_t td_iter_ = 0; td_iter_ < fqn.size(); td_iter_++) {
  auto& n = fqn[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == fqn.size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << n;
if (!IsLast()) {
os << "::";
} else {
}
}


}
std::string QualifiedName(const td::Vector<std::string>& fqn) {
  std::stringstream oss;
  QualifiedName(oss, fqn);
  return oss.str();
}
void QualifiedSnakeName(std::ostream& os, const td::Vector<std::string>& fqn) {


for (size_t td_iter_ = 0; td_iter_ < fqn.size(); td_iter_++) {
  auto& n = fqn[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == fqn.size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << n;
if (!IsLast()) {
os << "_";
} else {
}
}


}
std::string QualifiedSnakeName(const td::Vector<std::string>& fqn) {
  std::stringstream oss;
  QualifiedSnakeName(oss, fqn);
  return oss.str();
}
void JsonPrintKey(std::ostream& os, const AccessInfo& field) {
os << "os << \"\\\"";
os << field.identifier();
os << "\\\":\"";

}
std::string JsonPrintKey(const AccessInfo& field) {
  std::stringstream oss;
  JsonPrintKey(oss, field);
  return oss.str();
}
void JsonPrintArray(std::ostream& os, const AccessInfo& value_type) {
os << "\nos << \"[\";\nfor (size_t ii = 0; ii < arr.size(); ii++) {\n  const auto& val = arr[ii];\n  ";
// Switch value_type.td_type()

if (value_type.td_type().is_bool_t()) {
os << "os << (val ? \"true\" : \"false\");";
} else 
if (value_type.td_type().is_char_t()) {
os << "os << \"\\\"\" << char32ToJsonString(val) << \"\\\"\";";
} else 
if (value_type.td_type().is_u8_t()) {
os << "os << (int)val;";
} else 
if (value_type.td_type().is_i8_t()) {
os << "os << (int)val;";
} else 
if (value_type.td_type().is_string_t()) {
os << "os << \"\\\"\" << escape_json(val) << \"\\\"\";";
} else 
if (value_type.td_type().is_vector_t()) {
os << "{\n    auto& arr = val;\n    ";
JsonPrintArray(os, value_type.td_type().vector_t().val());
os << "\n  }";
} else 
if (value_type.td_type().is_map_t()) {
os << "{\n    auto& map = val;\n    ";
JsonPrintMap(os, value_type.td_type().map_t().key(), value_type.td_type().map_t().val());
os << "\n  }";
} else 
if (value_type.td_type().is_struct_t()) {
os << "ToJson(os, val);";
} else 
if (value_type.td_type().is_variant_t()) {
os << "ToJson(os, val);";
} else  {
os << "os << val;";
}
os << "\n  if (ii < arr.size() - 1) { os << \",\"; }\n}\nos << \"]\";\n";

}
std::string JsonPrintArray(const AccessInfo& value_type) {
  std::stringstream oss;
  JsonPrintArray(oss, value_type);
  return oss.str();
}
void JsonPrintMap(std::ostream& os, const AccessInfo& key_type, const AccessInfo& val_type) {
os << "\nos << \"{\";\nauto iter = map.begin();\nwhile (iter != map.end()) {\n  {\n  const auto& key = iter->first;\n  ";
// Switch key_type.td_type()

if (key_type.td_type().is_bool_t()) {
os << "os << (key ? \"\\\"true\\\"\" : \"\\\"false\\\"\");";
} else 
if (key_type.td_type().is_char_t()) {
os << "os << \"\\\"\" << char32ToJsonString(key) << \"\\\"\";";
} else 
if (key_type.td_type().is_u8_t()) {
os << "os << \"\\\"\" << std::to_string((int)key) << \"\\\"\";";
} else 
if (key_type.td_type().is_i8_t()) {
os << "os << \"\\\"\" << std::to_string((int)key) << \"\\\"\";";
} else 
if (key_type.td_type().is_string_t()) {
os << "os << \"\\\"\" << escape_json(key) << \"\\\"\";";
} else  {
os << "os << \"\\\"\" << std::to_string(key) << \"\\\"\";";
}
os << "\n  }\n  os << \":\";\n  {\n  const auto& val = iter->second;\n  ";
// Switch val_type.td_type()

if (val_type.td_type().is_bool_t()) {
os << "os << (val ? \"true\" : \"false\");";
} else 
if (val_type.td_type().is_char_t()) {
os << "os << \"\\\"\" << char32ToJsonString(val) << \"\\\"\";";
} else 
if (val_type.td_type().is_u8_t()) {
os << "os << (int)val;";
} else 
if (val_type.td_type().is_i8_t()) {
os << "os << (int)val;";
} else 
if (val_type.td_type().is_string_t()) {
os << "os << \"\\\"\" << escape_json(val) << \"\\\"\";";
} else 
if (val_type.td_type().is_vector_t()) {
os << "{\n    auto& arr = val;\n    ";
JsonPrintArray(os, val_type.td_type().vector_t().val());
os << "\n  }";
} else 
if (val_type.td_type().is_map_t()) {
os << "{\n    auto& map = val;\n    ";
JsonPrintMap(os, val_type.td_type().map_t().key(), val_type.td_type().map_t().val());
os << "\n  }";
} else 
if (val_type.td_type().is_struct_t()) {
os << "ToJson(os, val);";
} else 
if (val_type.td_type().is_variant_t()) {
os << "ToJson(os, val);";
} else  {
os << "os << val;";
}
os << "\n  }\n  ++iter;\n  if (iter != map.end()) { os << \",\"; }\n}\nos << \"}\";\n";

}
std::string JsonPrintMap(const AccessInfo& key_type, const AccessInfo& val_type) {
  std::stringstream oss;
  JsonPrintMap(oss, key_type, val_type);
  return oss.str();
}
void JsonPrintValue(std::ostream& os, const AccessInfo& t) {
os << "\n";
// Switch t.td_type()

if (t.td_type().is_bool_t()) {
JsonPrintKey(os, t);
os << "; os << (from.";
os << t.identifier();
os << "() ? \"true\" : \"false\");";
} else 
if (t.td_type().is_char_t()) {
JsonPrintKey(os, t);
os << "; os << \"\\\"\" << char32ToJsonString(from.";
os << t.identifier();
os << "()) << \"\\\"\";";
} else 
if (t.td_type().is_u8_t()) {
JsonPrintKey(os, t);
os << "; os << (int)from.";
os << t.identifier();
os << "();";
} else 
if (t.td_type().is_i8_t()) {
JsonPrintKey(os, t);
os << "; os << (int)from.";
os << t.identifier();
os << "();";
} else 
if (t.td_type().is_string_t()) {
JsonPrintKey(os, t);
os << "; os << \"\\\"\" << escape_json(from.";
os << t.identifier();
os << "()) << \"\\\"\";";
} else 
if (t.td_type().is_vector_t()) {
JsonPrintKey(os, t);
os << ";\n{\n  auto& arr = from.";
os << t.identifier();
os << "();\n  ";
JsonPrintArray(os, t.td_type().vector_t().val());
os << "\n}";
} else 
if (t.td_type().is_map_t()) {
JsonPrintKey(os, t);
os << ";\n{\n  auto& map = from.";
os << t.identifier();
os << "();\n  ";
JsonPrintMap(os, t.td_type().map_t().key(), t.td_type().map_t().val());
os << "\n}";
} else 
if (t.td_type().is_struct_t()) {
os << "if (from.has_";
os << t.identifier();
os << "()) {";
JsonPrintKey(os, t);
os << "; ToJson(os, from.";
os << t.identifier();
os << "());} else {";
JsonPrintKey(os, t);
os << "; os << \"null\";}";
} else 
if (t.td_type().is_variant_t()) {
os << "if (from.has_";
os << t.identifier();
os << "()) {";
JsonPrintKey(os, t);
os << "; ToJson(os, from.";
os << t.identifier();
os << "());} else {";
JsonPrintKey(os, t);
os << "; os << \"null\";}";
} else  {
JsonPrintKey(os, t);
os << "; os << from.";
os << t.identifier();
os << "();";
}
os << "\n";

}
std::string JsonPrintValue(const AccessInfo& t) {
  std::stringstream oss;
  JsonPrintValue(oss, t);
  return oss.str();
}
void JsonStructDefinitions(std::ostream& os, const StructDecl& s, const Options& opt) {
if (opt.generate_json_writer()) {
os << "\nstd::string ToJson(const ";
QualifiedName(os, s.nqn());
os << "& from) {\n  std::stringstream ss;\n  ToJson(ss, from);\n  return ss.str();\n}\nvoid ToJson(std::ostream& os, const ";
QualifiedName(os, s.nqn());
os << "& from) {\n  os << \"{\";\n  ";


for (size_t td_iter_ = 0; td_iter_ < s.fields().size(); td_iter_++) {
  auto& field = s.fields()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.fields().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
JsonPrintValue(os, field);
if (!IsLast()) {
os << "os << \",\";";
} else {
}
}

os << "\n  os << \"}\";\n}";
} else {
}
os << "\n";
if (opt.generate_json_parser()) {
os << "\n";
QualifiedName(os, s.nqn());
os << " ";
QualifiedName(os, s.nqn());
os << "::FromJson(const std::string& str) {\n  rapidjson::Document doc;\n  doc.Parse(str.c_str());\n  return JsonParse";
QualifiedSnakeName(os, s.nqn());
os << "(doc);\n}";
} else {
}
os << "\n";


for (size_t td_iter_ = 0; td_iter_ < s.nested_type_decls().size(); td_iter_++) {
  auto& n = s.nested_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.nested_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch n

if (n.is_struct_decl()) {
JsonStructDefinitions(os, n.struct_decl(), opt);
} else 
if (n.is_variant_decl()) {
JsonVariantDefinitions(os, n.variant_decl(), opt);
} else  {
}
}

os << "\n";


for (size_t td_iter_ = 0; td_iter_ < s.inline_type_decls().size(); td_iter_++) {
  auto& n = s.inline_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.inline_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch n

if (n.is_struct_decl()) {
JsonStructDefinitions(os, n.struct_decl(), opt);
} else 
if (n.is_variant_decl()) {
JsonVariantDefinitions(os, n.variant_decl(), opt);
} else  {
}
}


}
std::string JsonStructDefinitions(const StructDecl& s, const Options& opt) {
  std::stringstream oss;
  JsonStructDefinitions(oss, s, opt);
  return oss.str();
}
void JsonVariantDefinitions(std::ostream& os, const StructDecl& s, const Options& opt) {
if (opt.generate_json_writer()) {
os << "\nstd::string ToJson(const ";
QualifiedName(os, s.nqn());
os << "& from) {\n  std::stringstream ss;\n  ToJson(ss, from);\n  return ss.str();\n}\nvoid ToJson(std::ostream& os, const ";
QualifiedName(os, s.nqn());
os << "& from) {\n  os << \"{\";\n  ";


for (size_t td_iter_ = 0; td_iter_ < s.fields().size(); td_iter_++) {
  auto& field = s.fields()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.fields().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "\n  if (from.is_";
os << field.identifier();
os << "()) {\n    ";
JsonPrintValue(os, field);
os << "\n  }\n  ";
}

os << "\n  os << \"}\";\n}\n";
} else {
}
os << "\n";
if (opt.generate_json_parser()) {
os << "\n";
QualifiedName(os, s.nqn());
os << " ";
QualifiedName(os, s.nqn());
os << "::FromJson(const std::string& str) {\n  rapidjson::Document doc;\n  doc.Parse(str.c_str());\n  return JsonParse";
QualifiedSnakeName(os, s.nqn());
os << "(doc);\n}";
} else {
}
os << "\n";


for (size_t td_iter_ = 0; td_iter_ < s.nested_type_decls().size(); td_iter_++) {
  auto& n = s.nested_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.nested_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch n

if (n.is_struct_decl()) {
JsonStructDefinitions(os, n.struct_decl(), opt);
} else 
if (n.is_variant_decl()) {
JsonVariantDefinitions(os, n.variant_decl(), opt);
} else  {
}
}

os << "\n";


for (size_t td_iter_ = 0; td_iter_ < s.inline_type_decls().size(); td_iter_++) {
  auto& n = s.inline_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.inline_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch n

if (n.is_struct_decl()) {
JsonStructDefinitions(os, n.struct_decl(), opt);
} else 
if (n.is_variant_decl()) {
JsonVariantDefinitions(os, n.variant_decl(), opt);
} else  {
}
}


}
std::string JsonVariantDefinitions(const StructDecl& s, const Options& opt) {
  std::stringstream oss;
  JsonVariantDefinitions(oss, s, opt);
  return oss.str();
}
void JsonSrcForwardDeclarations(std::ostream& os, const StructDecl& s, const Options& opt) {
if (opt.generate_json_parser()) {
os << "\n";
QualifiedName(os, s.fqn());
os << " JsonParse";
QualifiedSnakeName(os, s.nqn());
os << "(const rapidjson::Value& obj);\n";


for (size_t td_iter_ = 0; td_iter_ < s.nested_type_decls().size(); td_iter_++) {
  auto& n = s.nested_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.nested_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch n

if (n.is_struct_decl()) {
JsonSrcForwardDeclarations(os, n.struct_decl(), opt);
} else 
if (n.is_variant_decl()) {
JsonSrcForwardDeclarations(os, n.variant_decl(), opt);
} else  {
}
}



for (size_t td_iter_ = 0; td_iter_ < s.inline_type_decls().size(); td_iter_++) {
  auto& n = s.inline_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.inline_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch n

if (n.is_struct_decl()) {
JsonSrcForwardDeclarations(os, n.struct_decl(), opt);
} else 
if (n.is_variant_decl()) {
JsonSrcForwardDeclarations(os, n.variant_decl(), opt);
} else  {
}
}

} else {
}

}
std::string JsonSrcForwardDeclarations(const StructDecl& s, const Options& opt) {
  std::stringstream oss;
  JsonSrcForwardDeclarations(oss, s, opt);
  return oss.str();
}
void JsonParseArrayLambda(std::ostream& os, const AccessInfo& from_type) {
os << "\nauto json_parse_array_lambda = [](auto& value_type, const rapidjson::Value& src) {\n  using VectorType = std::remove_reference_t<decltype(value_type)>;\n  VectorType vec;\n  for (rapidjson::SizeType ii = 0; ii < src.Size(); ii++) {\n    ";
// Switch from_type.td_type()

if (from_type.td_type().is_bool_t()) {
os << "vec.push_back(JsonParseBool(src[ii]));";
} else 
if (from_type.td_type().is_char_t()) {
os << "vec.push_back(JsonParseChar(src[ii]));";
} else 
if (from_type.td_type().is_string_t()) {
os << "vec.push_back(JsonParseStr(src[ii]));";
} else 
if (from_type.td_type().is_f32_t()) {
os << "vec.push_back(JsonParseF32(src[ii]));";
} else 
if (from_type.td_type().is_f64_t()) {
os << "vec.push_back(JsonParseF64(src[ii]));";
} else 
if (from_type.td_type().is_u8_t()) {
os << "vec.push_back(JsonParseU8(src[ii]));";
} else 
if (from_type.td_type().is_u16_t()) {
os << "vec.push_back(JsonParseU16(src[ii]));";
} else 
if (from_type.td_type().is_u32_t()) {
os << "vec.push_back(JsonParseU32(src[ii]));";
} else 
if (from_type.td_type().is_u64_t()) {
os << "vec.push_back(JsonParseU64(src[ii]));";
} else 
if (from_type.td_type().is_i8_t()) {
os << "vec.push_back(JsonParseI8(src[ii]));";
} else 
if (from_type.td_type().is_i16_t()) {
os << "vec.push_back(JsonParseI16(src[ii]));";
} else 
if (from_type.td_type().is_i32_t()) {
os << "vec.push_back(JsonParseI32(src[ii]));";
} else 
if (from_type.td_type().is_i64_t()) {
os << "vec.push_back(JsonParseI64(src[ii]));";
} else 
if (from_type.td_type().is_vector_t()) {
os << "\n    if (src.IsArray()) {\n      vec.emplace_back();\n      auto& innerVec = vec.back();\n      ";
JsonParseArrayLambda(os, from_type.td_type().vector_t().val());
os << "\n      innerVec = json_parse_array_lambda(innerVec, src[ii]);\n    }";
} else 
if (from_type.td_type().is_struct_t()) {
os << "\n      vec.push_back(JsonParse";
QualifiedSnakeName(os, from_type.td_type().struct_t().nqn());
os << "(src[ii]));\n    ";
} else 
if (from_type.td_type().is_variant_t()) {
os << "\n      if (src[ii].MemberCount() > 1) {\n        throw std::runtime_error(\"One member expected for variant type; found \" + std::to_string(val.MemberCount()));\n      }\n      vec.push_back(JsonParse";
QualifiedSnakeName(os, from_type.td_type().variant_t().nqn());
os << "(src[ii]));\n    ";
} else  {
}
os << "\n  }\n  return vec;\n};\n";

}
std::string JsonParseArrayLambda(const AccessInfo& from_type) {
  std::stringstream oss;
  JsonParseArrayLambda(oss, from_type);
  return oss.str();
}
void JsonParseMapLambda(std::ostream& os, const AccessInfo& key_type, const AccessInfo& val_type) {
os << "\nauto json_parse_map_lambda = [](auto& value_type, const rapidjson::Value& src) {\n  using MapType = std::remove_reference_t<decltype(value_type)>;\n  MapType map;\n  using KeyType = typename MapType::key_type;\n  using ValType = typename MapType::mapped_type;\n  using PairType = std::pair<const KeyType, ValType>;\n  for (auto& m : src.GetObject()) {\n    ";
// Switch key_type.td_type()

if (key_type.td_type().is_bool_t()) {
os << "KeyType key = JsonParseBool(m.name);";
} else 
if (key_type.td_type().is_char_t()) {
os << "KeyType key = JsonParseChar(m.name);";
} else 
if (key_type.td_type().is_string_t()) {
os << "KeyType key = JsonParseStr(m.name);";
} else 
if (key_type.td_type().is_f32_t()) {
os << "KeyType key = JsonParseF32(m.name);";
} else 
if (key_type.td_type().is_f64_t()) {
os << "KeyType key = JsonParseF64(m.name);";
} else 
if (key_type.td_type().is_u8_t()) {
os << "KeyType key = JsonParseU8(m.name);";
} else 
if (key_type.td_type().is_u16_t()) {
os << "KeyType key = JsonParseU16(m.name);";
} else 
if (key_type.td_type().is_u32_t()) {
os << "KeyType key = JsonParseU32(m.name);";
} else 
if (key_type.td_type().is_u64_t()) {
os << "KeyType key = JsonParseU64(m.name);";
} else 
if (key_type.td_type().is_i8_t()) {
os << "KeyType key = JsonParseI8(m.name);";
} else 
if (key_type.td_type().is_i16_t()) {
os << "KeyType key = JsonParseI16(m.name);";
} else 
if (key_type.td_type().is_i32_t()) {
os << "KeyType key = JsonParseI32(m.name);";
} else 
if (key_type.td_type().is_i64_t()) {
os << "KeyType key = JsonParseI64(m.name);";
} else  {
os << "#error If this was emitted then there's a problem with map key type checking.";
}
os << "\n\n    ";
// Switch val_type.td_type()

if (val_type.td_type().is_bool_t()) {
os << "ValType map_val = JsonParseBool(m.value);";
} else 
if (val_type.td_type().is_char_t()) {
os << "ValType map_val = JsonParseChar(m.value);";
} else 
if (val_type.td_type().is_string_t()) {
os << "ValType map_val = JsonParseStr(m.value);";
} else 
if (val_type.td_type().is_f32_t()) {
os << "ValType map_val = JsonParseF32(m.value);";
} else 
if (val_type.td_type().is_f64_t()) {
os << "ValType map_val = JsonParseF64(m.value);";
} else 
if (val_type.td_type().is_u8_t()) {
os << "ValType map_val = JsonParseU8(m.value);";
} else 
if (val_type.td_type().is_u16_t()) {
os << "ValType map_val = JsonParseU16(m.value);";
} else 
if (val_type.td_type().is_u32_t()) {
os << "ValType map_val = JsonParseU32(m.value);";
} else 
if (val_type.td_type().is_u64_t()) {
os << "ValType map_val = JsonParseU64(m.value);";
} else 
if (val_type.td_type().is_i8_t()) {
os << "ValType map_val = JsonParseI8(m.value);";
} else 
if (val_type.td_type().is_i16_t()) {
os << "ValType map_val = JsonParseI16(m.value);";
} else 
if (val_type.td_type().is_i32_t()) {
os << "ValType map_val = JsonParseI32(m.value);";
} else 
if (val_type.td_type().is_i64_t()) {
os << "ValType map_val = JsonParseI64(m.value);";
} else 
if (val_type.td_type().is_vector_t()) {
os << "\n    ValType map_val;\n    if (m.value.IsArray()) {\n      ";
JsonParseArrayLambda(os, val_type.td_type().vector_t().val());
os << "\n      map_val = json_parse_array_lambda(map_val, m.value);\n    } else {\n      throw std::runtime_error(\"JSON format error: expected 'array'.\");\n    }";
} else 
if (val_type.td_type().is_map_t()) {
os << "\n    ValType map_val;\n    if (m.value.IsObject()) {\n      ";
JsonParseMapLambda(os, val_type.td_type().map_t().key(), val_type.td_type().map_t().val());
os << "\n      map_val = json_parse_map_lambda(map_val, m.value);\n    } else {\n      throw std::runtime_error(\"JSON format error: expected 'object'.\");\n    }";
} else 
if (val_type.td_type().is_struct_t()) {
os << "\n    ValType map_val;\n    if (m.value.IsObject()) {\n      map_val = JsonParse";
QualifiedSnakeName(os, val_type.td_type().struct_t().nqn());
os << "(m.value);\n    } else {\n      throw std::runtime_error(\"JSON format error: expected 'object'.\");\n    }";
} else 
if (val_type.td_type().is_variant_t()) {
os << "\n    ValType map_val;\n    if (m.value.IsObject()) {\n      if (m.value.MemberCount() > 1) {\n        throw std::runtime_error(\"JSON format error: one member expected for variant type; found \" + std::to_string(m.value.MemberCount()));\n      }\n      map_val = JsonParse";
QualifiedSnakeName(os, val_type.td_type().variant_t().nqn());
os << "(m.value);\n    } else {\n      throw std::runtime_error(\"JSON format error: expected 'object'.\");\n    }";
} else  {
}
os << "\n\n    map.emplace(std::make_pair(key, std::move(map_val)));\n  }\n  return map;\n};\n";

}
std::string JsonParseMapLambda(const AccessInfo& key_type, const AccessInfo& val_type) {
  std::stringstream oss;
  JsonParseMapLambda(oss, key_type, val_type);
  return oss.str();
}
void JsonSrcDefinitions(std::ostream& os, const StructDecl& s, const Options& opt) {
if (opt.generate_json_parser()) {
os << "\n";
QualifiedName(os, s.fqn());
os << " JsonParse";
QualifiedSnakeName(os, s.nqn());
os << "(const rapidjson::Value& val) {\n  if (!val.IsObject()) {\n    throw std::runtime_error(\"JSON format error: expected 'object'.\");\n  }\n  ";
QualifiedName(os, s.fqn());
os << " ret;\n  ";


for (size_t td_iter_ = 0; td_iter_ < s.fields().size(); td_iter_++) {
  auto& field = s.fields()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.fields().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "{\n  auto obj = val.GetObject();\n  rapidjson::Value::ConstMemberIterator iter = obj.FindMember(\"";
os << field.identifier();
os << "\");\n  if (iter != obj.MemberEnd()) {\n    auto& val = iter->value;\n    ";
// Switch field.td_type()

if (field.td_type().is_bool_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseBool(val);";
} else 
if (field.td_type().is_char_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseChar(val);";
} else 
if (field.td_type().is_string_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseStr(val);";
} else 
if (field.td_type().is_f32_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseF32(val);";
} else 
if (field.td_type().is_f64_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseF64(val);";
} else 
if (field.td_type().is_u8_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseU8(val);";
} else 
if (field.td_type().is_u16_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseU16(val);";
} else 
if (field.td_type().is_u32_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseU32(val);";
} else 
if (field.td_type().is_u64_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseU64(val);";
} else 
if (field.td_type().is_i8_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseI8(val);";
} else 
if (field.td_type().is_i16_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseI16(val);";
} else 
if (field.td_type().is_i32_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseI32(val);";
} else 
if (field.td_type().is_i64_t()) {
os << "ret.";
os << field.identifier();
os << "() = JsonParseI64(val);";
} else 
if (field.td_type().is_vector_t()) {
os << "\n    if (val.IsArray()) {\n      ";
JsonParseArrayLambda(os, field.td_type().vector_t().val());
os << "\n      ret.";
os << field.identifier();
os << "() = json_parse_array_lambda(ret.";
os << field.identifier();
os << "(), val);\n    } else {\n      throw std::runtime_error(\"JSON format error: expected 'array'.\");\n    }";
} else 
if (field.td_type().is_map_t()) {
os << "\n    if (val.IsObject()) {\n      ";
JsonParseMapLambda(os, field.td_type().map_t().key(), field.td_type().map_t().val());
os << "\n      ret.";
os << field.identifier();
os << "() = json_parse_map_lambda(ret.";
os << field.identifier();
os << "(), val);\n    } else {\n      throw std::runtime_error(\"JSON format error: expected 'object'.\");\n    }\n    ";
} else 
if (field.td_type().is_struct_t()) {
os << "\n    if (val.IsObject()) {\n      ret.";
os << field.identifier();
os << "() = JsonParse";
QualifiedSnakeName(os, field.td_type().struct_t().nqn());
os << "(val);\n    } else {\n      throw std::runtime_error(\"JSON format error: expected 'object'.\");\n    }";
} else 
if (field.td_type().is_variant_t()) {
os << "\n    if (val.IsObject()) {\n      if (val.MemberCount() > 1) {\n        throw std::runtime_error(\"JSON format error: one member expected for variant type; found \" + std::to_string(val.MemberCount()));\n      }\n      ret.";
os << field.identifier();
os << "() = JsonParse";
QualifiedSnakeName(os, field.td_type().variant_t().nqn());
os << "(val);\n    } else {\n      throw std::runtime_error(\"JSON format error: expected 'object'.\");\n    }";
} else  {
}
os << "\n  }\n  } ";
}

os << "\n  return ret;\n}\n";


for (size_t td_iter_ = 0; td_iter_ < s.nested_type_decls().size(); td_iter_++) {
  auto& n = s.nested_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.nested_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch n

if (n.is_struct_decl()) {
JsonSrcDefinitions(os, n.struct_decl(), opt);
} else 
if (n.is_variant_decl()) {
JsonSrcDefinitions(os, n.variant_decl(), opt);
} else  {
}
}



for (size_t td_iter_ = 0; td_iter_ < s.inline_type_decls().size(); td_iter_++) {
  auto& n = s.inline_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.inline_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch n

if (n.is_struct_decl()) {
JsonSrcDefinitions(os, n.struct_decl(), opt);
} else 
if (n.is_variant_decl()) {
JsonSrcDefinitions(os, n.variant_decl(), opt);
} else  {
}
}

os << "\n";
} else {
}

}
std::string JsonSrcDefinitions(const StructDecl& s, const Options& opt) {
  std::stringstream oss;
  JsonSrcDefinitions(oss, s, opt);
  return oss.str();
}
void JsonDeclarations(std::ostream& os, const StructDecl& s, const Options& opt) {
if (opt.generate_json_writer()) {
os << "\nstd::string ToJson(const ";
QualifiedName(os, s.nqn());
os << "& from);\nvoid ToJson(std::ostream& os, const ";
QualifiedName(os, s.nqn());
os << "& from);\n";
} else {
}
os << "\n";


for (size_t td_iter_ = 0; td_iter_ < s.nested_type_decls().size(); td_iter_++) {
  auto& n = s.nested_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.nested_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch n

if (n.is_struct_decl()) {
JsonDeclarations(os, n.struct_decl(), opt);
} else 
if (n.is_variant_decl()) {
JsonDeclarations(os, n.variant_decl(), opt);
} else  {
}
}

os << "\n";


for (size_t td_iter_ = 0; td_iter_ < s.inline_type_decls().size(); td_iter_++) {
  auto& n = s.inline_type_decls()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.inline_type_decls().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
// Switch n

if (n.is_struct_decl()) {
JsonDeclarations(os, n.struct_decl(), opt);
} else 
if (n.is_variant_decl()) {
JsonDeclarations(os, n.variant_decl(), opt);
} else  {
}
}


}
std::string JsonDeclarations(const StructDecl& s, const Options& opt) {
  std::stringstream oss;
  JsonDeclarations(oss, s, opt);
  return oss.str();
}
void TmplValueDereferenceT(std::ostream& os, const TmplValueDereference& v) {


for (size_t td_iter_ = 0; td_iter_ < v.val_ref_path().size(); td_iter_++) {
  auto& part = v.val_ref_path()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == v.val_ref_path().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << part;
if (!IsFirst()) {
os << "()";
} else {
}
if (!IsLast()) {
os << ".";
} else {
}
}


}
std::string TmplValueDereferenceT(const TmplValueDereference& v) {
  std::stringstream oss;
  TmplValueDereferenceT(oss, v);
  return oss.str();
}
void TmplStringExpression(std::ostream& os, const TmplExpression& i) {
// Switch i

if (i.is_call()) {
os << i.call().identifier();
os << "(";


for (size_t td_iter_ = 0; td_iter_ < i.call().args().size(); td_iter_++) {
  auto& arg = i.call().args()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == i.call().args().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
TmplValueDereferenceT(os, arg.val_ref());
if (!IsLast()) {
os << ",";
} else {
}
}

os << ")";
} else 
if (i.is_val_ref()) {
TmplValueDereferenceT(os, i.val_ref());
} else 
if (i.is_expr()) {
os << "(";
TmplStringExpression(os, i.expr());
os << ")";
} else  {
os << "#error If this was emitted then there's a problem with type checking.";
}

}
std::string TmplStringExpression(const TmplExpression& i) {
  std::stringstream oss;
  TmplStringExpression(oss, i);
  return oss.str();
}
void TmplOStreamExpression(std::ostream& os, const TmplExpression& i) {
// Switch i

if (i.is_call()) {
os << i.call().identifier();
os << "(os";


for (size_t td_iter_ = 0; td_iter_ < i.call().args().size(); td_iter_++) {
  auto& arg = i.call().args()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == i.call().args().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << ", ";
TmplStringExpression(os, arg);
}

os << ")";
} else 
if (i.is_val_ref()) {
os << "os << ";
TmplValueDereferenceT(os, i.val_ref());
} else 
if (i.is_expr()) {
os << "(";
TmplOStreamExpression(os, i.expr());
os << ")";
} else  {
os << "#error If this was emitted then there's a problem with type checking.";
}

}
std::string TmplOStreamExpression(const TmplExpression& i) {
  std::stringstream oss;
  TmplOStreamExpression(oss, i);
  return oss.str();
}
void TmplBoolExpression(std::ostream& os, const TmplExpression& i) {
// Switch i

if (i.is_call()) {
os << i.call().identifier();
os << "(";


for (size_t td_iter_ = 0; td_iter_ < i.call().args().size(); td_iter_++) {
  auto& arg = i.call().args()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == i.call().args().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
TmplValueDereferenceT(os, arg.val_ref());
if (!IsLast()) {
os << ", ";
} else {
}
}

os << ")";
} else 
if (i.is_val_ref()) {
TmplValueDereferenceT(os, i.val_ref());
} else 
if (i.is_expr()) {
os << "(";
TmplBoolExpression(os, i.expr());
os << ")";
} else 
if (i.is_not_expr()) {
os << "!";
TmplBoolExpression(os, i.not_expr());
} else  {
}

}
std::string TmplBoolExpression(const TmplExpression& i) {
  std::stringstream oss;
  TmplBoolExpression(oss, i);
  return oss.str();
}
void TmplIfT(std::ostream& os, const TmplIf& i) {
os << "if (";
TmplBoolExpression(os, i.expr());
os << ") {\n";
TmplItemsT(os, i.items());
os << "}";

}
std::string TmplIfT(const TmplIf& i) {
  std::stringstream oss;
  TmplIfT(oss, i);
  return oss.str();
}
void TmplIfBlockT(std::ostream& os, const TmplIfBlock& i) {
TmplIfT(os, i.if_sublock());


for (size_t td_iter_ = 0; td_iter_ < i.elifs().size(); td_iter_++) {
  auto& e = i.elifs()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == i.elifs().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << " else ";
TmplIfT(os, e);
}

os << " else {\n";
TmplItemsT(os, i.else_items());
os << "}";

}
std::string TmplIfBlockT(const TmplIfBlock& i) {
  std::stringstream oss;
  TmplIfBlockT(oss, i);
  return oss.str();
}
void TmplForT(std::ostream& os, const TmplForBlock& f) {
os << "\n";
// Switch f.binding_vars()

if (f.binding_vars().is_var()) {
os << "\nfor (size_t td_iter_ = 0; td_iter_ < ";
TmplValueDereferenceT(os, f.collection());
os << ".size(); td_iter_++) {\n  auto& ";
os << f.binding_vars().var();
os << " = ";
TmplValueDereferenceT(os, f.collection());
os << "[td_iter_];\n  auto IsFirst = [&]() { return td_iter_ == 0; };\n  auto IsLast = [&]() { return td_iter_ == ";
TmplValueDereferenceT(os, f.collection());
os << ".size() - 1; };\n  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };\n  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };\n";
} else 
if (f.binding_vars().is_key_val()) {
os << "\nfor (auto const& [";
os << f.binding_vars().key_val().key();
os << ", ";
os << f.binding_vars().key_val().val();
os << "] : ";
TmplValueDereferenceT(os, f.collection());
os << ") {\n";
} else  {
}
TmplItemsT(os, f.items());
os << "}\n";

}
std::string TmplForT(const TmplForBlock& f) {
  std::stringstream oss;
  TmplForT(oss, f);
  return oss.str();
}
void TmplHasValRef(std::ostream& os, const TmplValueDereference& val) {


for (size_t td_iter_ = 0; td_iter_ < val.val_ref_path().size(); td_iter_++) {
  auto& part = val.val_ref_path()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == val.val_ref_path().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
if (IsLast()) {
os << "is_";
} else {
}
os << part;
if (!IsFirst()) {
os << "()";
} else {
}
if (!IsLast()) {
os << ".";
} else {
}
}


}
std::string TmplHasValRef(const TmplValueDereference& val) {
  std::stringstream oss;
  TmplHasValRef(oss, val);
  return oss.str();
}
void TmplSwitchT(std::ostream& os, const SwitchBlock& s) {
os << "// Switch ";
TmplValueDereferenceT(os, s.identifier());
os << "\n";


for (size_t td_iter_ = 0; td_iter_ < s.cases().size(); td_iter_++) {
  auto& c = s.cases()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == s.cases().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "\nif (";
TmplHasValRef(os, c.label());
os << ") {\n";
TmplItemsT(os, c.items());
os << "} else ";
}

os << " {\n";
TmplItemsT(os, s.default_subblock());
os << "}";

}
std::string TmplSwitchT(const SwitchBlock& s) {
  std::stringstream oss;
  TmplSwitchT(oss, s);
  return oss.str();
}
void TmplItemsT(std::ostream& os, const td::Vector<TmplItem>& v) {


for (size_t td_iter_ = 0; td_iter_ < v.size(); td_iter_++) {
  auto& i = v[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == v.size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
TmplItemT(os, i);
os << "\n";
}


}
std::string TmplItemsT(const td::Vector<TmplItem>& v) {
  std::stringstream oss;
  TmplItemsT(oss, v);
  return oss.str();
}
void TmplItemT(std::ostream& os, const TmplItem& i) {
// Switch i

if (i.is_text()) {
os << "os << \"";
os << i.text();
os << "\";";
} else 
if (i.is_expression()) {
TmplOStreamExpression(os, i.expression());
os << ";";
} else 
if (i.is_if_block()) {
TmplIfBlockT(os, i.if_block());
} else 
if (i.is_for_block()) {
TmplForT(os, i.for_block());
} else 
if (i.is_switch_block()) {
TmplSwitchT(os, i.switch_block());
} else  {
}

}
std::string TmplItemT(const TmplItem& i) {
  std::stringstream oss;
  TmplItemT(oss, i);
  return oss.str();
}
void OStreamParamsList(std::ostream& os, const td::Vector<AccessInfo>& params) {
os << "std::ostream& os";


for (size_t td_iter_ = 0; td_iter_ < params.size(); td_iter_++) {
  auto& param = params[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == params.size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << ", const ";
CppType(os, param);
os << "& ";
os << param.identifier();
}


}
std::string OStreamParamsList(const td::Vector<AccessInfo>& params) {
  std::stringstream oss;
  OStreamParamsList(oss, params);
  return oss.str();
}
void ParamsList(std::ostream& os, const td::Vector<AccessInfo>& params) {


for (size_t td_iter_ = 0; td_iter_ < params.size(); td_iter_++) {
  auto& param = params[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == params.size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "const ";
CppType(os, param);
os << "& ";
os << param.identifier();
if (!IsLast()) {
os << ", ";
} else {
}
}


}
std::string ParamsList(const td::Vector<AccessInfo>& params) {
  std::stringstream oss;
  ParamsList(oss, params);
  return oss.str();
}
void TmplFuncDeclaration(std::ostream& os, const TmplFunction& t) {
os << "void ";
os << t.identifier();
os << "(";
OStreamParamsList(os, t.params());
os << ");\nstd::string ";
os << t.identifier();
os << "(";
ParamsList(os, t.params());
os << ");";

}
std::string TmplFuncDeclaration(const TmplFunction& t) {
  std::stringstream oss;
  TmplFuncDeclaration(oss, t);
  return oss.str();
}
void TmplFuncDefinition(std::ostream& os, const TmplFunction& t) {
os << "\nvoid ";
os << t.identifier();
os << "(";
OStreamParamsList(os, t.params());
os << ") {\n";
TmplItemsT(os, t.items());
os << "\n}\nstd::string ";
os << t.identifier();
os << "(";
ParamsList(os, t.params());
os << ") {\n  std::stringstream oss;\n  ";
os << t.identifier();
os << "(oss";


for (size_t td_iter_ = 0; td_iter_ < t.params().size(); td_iter_++) {
  auto& param = t.params()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == t.params().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << ", ";
os << param.identifier();
}

os << ");\n  return oss.str();\n}";

}
std::string TmplFuncDefinition(const TmplFunction& t) {
  std::stringstream oss;
  TmplFuncDefinition(oss, t);
  return oss.str();
}

} // namespace td
} // namespace codegen
} // namespace experimental
} // namespace cpp


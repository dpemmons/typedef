
#ifndef TD_CODEGEN_CPP_TD_CPP_H__
#define TD_CODEGEN_CPP_TD_CPP_H__

#include <cstdint>
#include <map>
#include <memory>
#include <string>
#include <variant>
#include <vector>
#include <ostream>

#include <typedef/builtin_types.h>

// Generated by the Typedef compiler

#ifndef TD_THROW
#define TD_STRINGIZE_DETAIL(x) #x
#define TD_STRINGIZE(x) TD_STRINGIZE_DETAIL(x)
#define TD_THROW(msg) (throw msg __FILE__ ":" TD_STRINGIZE(__LINE__))
#endif

#ifndef TD_AUTO_ALLOC
#define TD_AUTO_ALLOC 1
#endif

namespace td {
namespace codegen {
namespace cpp {

// Forward declarations.
class TdType;
class AccessInfo;
class StructDecl;
class UserTypeDeclaration;
class TmplValueDereference;
class TmplFuncCall;
class TmplExpression;
class TmplIf;
class TmplIfBlock;
class TmplForBlock;
class SwitchCase;
class SwitchBlock;
class TmplItem;
class TmplFunction;
class Options;
class CppData;

// Struct and variant declarations

// td::codegen::cpp::TdType variant declaration.
class TdType {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

// TdType::bool_tT struct declaration.
class bool_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  bool_tT() {}
  ~bool_tT() {}

  bool_tT(const bool_tT&) = delete;
  bool_tT& operator=(const bool_tT&) = delete;
  bool_tT(bool_tT&&) = default;
  bool_tT& operator=(bool_tT&&) = default;

  

  
  
  bool get_default_val() const {
    return default_val_;
  }
  void set_default_val(bool val) {
    default_val_ = val;
  }
  bool& default_val() {
    return default_val_;
  }
  const bool& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  bool default_val_ = 0;
  
}; // class bool_tT



// TdType::char_tT struct declaration.
class char_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  char_tT() {}
  ~char_tT() {}

  char_tT(const char_tT&) = delete;
  char_tT& operator=(const char_tT&) = delete;
  char_tT(char_tT&&) = default;
  char_tT& operator=(char_tT&&) = default;

  

  
  
  char32_t get_default_val() const {
    return default_val_;
  }
  void set_default_val(char32_t val) {
    default_val_ = val;
  }
  char32_t& default_val() {
    return default_val_;
  }
  const char32_t& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  char32_t default_val_ = U'\U00000000';
  
}; // class char_tT



// TdType::str_tT struct declaration.
class str_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  str_tT() {}
  ~str_tT() {}

  str_tT(const str_tT&) = delete;
  str_tT& operator=(const str_tT&) = delete;
  str_tT(str_tT&&) = default;
  str_tT& operator=(str_tT&&) = default;

  

  
  
  void set_default_val(std::string&& val) {
    default_val_ = std::move(val);
  }
  std::string& default_val() {
    return default_val_;
  }
  const std::string& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  std::string default_val_ = "";
  
}; // class str_tT



// TdType::f32_tT struct declaration.
class f32_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  f32_tT() {}
  ~f32_tT() {}

  f32_tT(const f32_tT&) = delete;
  f32_tT& operator=(const f32_tT&) = delete;
  f32_tT(f32_tT&&) = default;
  f32_tT& operator=(f32_tT&&) = default;

  

  
  
  float get_default_val() const {
    return default_val_;
  }
  void set_default_val(float val) {
    default_val_ = val;
  }
  float& default_val() {
    return default_val_;
  }
  const float& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  float default_val_ = 0;
  
}; // class f32_tT



// TdType::f64_tT struct declaration.
class f64_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  f64_tT() {}
  ~f64_tT() {}

  f64_tT(const f64_tT&) = delete;
  f64_tT& operator=(const f64_tT&) = delete;
  f64_tT(f64_tT&&) = default;
  f64_tT& operator=(f64_tT&&) = default;

  

  
  
  double get_default_val() const {
    return default_val_;
  }
  void set_default_val(double val) {
    default_val_ = val;
  }
  double& default_val() {
    return default_val_;
  }
  const double& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  double default_val_ = 0;
  
}; // class f64_tT



// TdType::u8_tT struct declaration.
class u8_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  u8_tT() {}
  ~u8_tT() {}

  u8_tT(const u8_tT&) = delete;
  u8_tT& operator=(const u8_tT&) = delete;
  u8_tT(u8_tT&&) = default;
  u8_tT& operator=(u8_tT&&) = default;

  

  
  
  std::uint8_t get_default_val() const {
    return default_val_;
  }
  void set_default_val(std::uint8_t val) {
    default_val_ = val;
  }
  std::uint8_t& default_val() {
    return default_val_;
  }
  const std::uint8_t& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  std::uint8_t default_val_ = 0;
  
}; // class u8_tT



// TdType::u16_tT struct declaration.
class u16_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  u16_tT() {}
  ~u16_tT() {}

  u16_tT(const u16_tT&) = delete;
  u16_tT& operator=(const u16_tT&) = delete;
  u16_tT(u16_tT&&) = default;
  u16_tT& operator=(u16_tT&&) = default;

  

  
  
  std::uint16_t get_default_val() const {
    return default_val_;
  }
  void set_default_val(std::uint16_t val) {
    default_val_ = val;
  }
  std::uint16_t& default_val() {
    return default_val_;
  }
  const std::uint16_t& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  std::uint16_t default_val_ = 0;
  
}; // class u16_tT



// TdType::u32_tT struct declaration.
class u32_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  u32_tT() {}
  ~u32_tT() {}

  u32_tT(const u32_tT&) = delete;
  u32_tT& operator=(const u32_tT&) = delete;
  u32_tT(u32_tT&&) = default;
  u32_tT& operator=(u32_tT&&) = default;

  

  
  
  std::uint32_t get_default_val() const {
    return default_val_;
  }
  void set_default_val(std::uint32_t val) {
    default_val_ = val;
  }
  std::uint32_t& default_val() {
    return default_val_;
  }
  const std::uint32_t& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  std::uint32_t default_val_ = 0;
  
}; // class u32_tT



// TdType::u64_tT struct declaration.
class u64_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  u64_tT() {}
  ~u64_tT() {}

  u64_tT(const u64_tT&) = delete;
  u64_tT& operator=(const u64_tT&) = delete;
  u64_tT(u64_tT&&) = default;
  u64_tT& operator=(u64_tT&&) = default;

  

  
  
  std::uint64_t get_default_val() const {
    return default_val_;
  }
  void set_default_val(std::uint64_t val) {
    default_val_ = val;
  }
  std::uint64_t& default_val() {
    return default_val_;
  }
  const std::uint64_t& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  std::uint64_t default_val_ = 0;
  
}; // class u64_tT



// TdType::i8_tT struct declaration.
class i8_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  i8_tT() {}
  ~i8_tT() {}

  i8_tT(const i8_tT&) = delete;
  i8_tT& operator=(const i8_tT&) = delete;
  i8_tT(i8_tT&&) = default;
  i8_tT& operator=(i8_tT&&) = default;

  

  
  
  std::int8_t get_default_val() const {
    return default_val_;
  }
  void set_default_val(std::int8_t val) {
    default_val_ = val;
  }
  std::int8_t& default_val() {
    return default_val_;
  }
  const std::int8_t& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  std::int8_t default_val_ = 0;
  
}; // class i8_tT



// TdType::i16_tT struct declaration.
class i16_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  i16_tT() {}
  ~i16_tT() {}

  i16_tT(const i16_tT&) = delete;
  i16_tT& operator=(const i16_tT&) = delete;
  i16_tT(i16_tT&&) = default;
  i16_tT& operator=(i16_tT&&) = default;

  

  
  
  std::int16_t get_default_val() const {
    return default_val_;
  }
  void set_default_val(std::int16_t val) {
    default_val_ = val;
  }
  std::int16_t& default_val() {
    return default_val_;
  }
  const std::int16_t& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  std::int16_t default_val_ = 0;
  
}; // class i16_tT



// TdType::i32_tT struct declaration.
class i32_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  i32_tT() {}
  ~i32_tT() {}

  i32_tT(const i32_tT&) = delete;
  i32_tT& operator=(const i32_tT&) = delete;
  i32_tT(i32_tT&&) = default;
  i32_tT& operator=(i32_tT&&) = default;

  

  
  
  std::int32_t get_default_val() const {
    return default_val_;
  }
  void set_default_val(std::int32_t val) {
    default_val_ = val;
  }
  std::int32_t& default_val() {
    return default_val_;
  }
  const std::int32_t& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  std::int32_t default_val_ = 0;
  
}; // class i32_tT



// TdType::i64_tT struct declaration.
class i64_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  i64_tT() {}
  ~i64_tT() {}

  i64_tT(const i64_tT&) = delete;
  i64_tT& operator=(const i64_tT&) = delete;
  i64_tT(i64_tT&&) = default;
  i64_tT& operator=(i64_tT&&) = default;

  

  
  
  std::int64_t get_default_val() const {
    return default_val_;
  }
  void set_default_val(std::int64_t val) {
    default_val_ = val;
  }
  std::int64_t& default_val() {
    return default_val_;
  }
  const std::int64_t& default_val() const {
    return default_val_;
  }
  
  

 private:
  // default_val
  std::int64_t default_val_ = 0;
  
}; // class i64_tT



// TdType::vector_tT struct declaration.
class vector_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  vector_tT() {}
  ~vector_tT() {}

  vector_tT(const vector_tT&) = delete;
  vector_tT& operator=(const vector_tT&) = delete;
  vector_tT(vector_tT&&) = default;
  vector_tT& operator=(vector_tT&&) = default;

  

  
  
  bool has_val() const {
    return val_.operator bool();
  }
  void alloc_val() {
    val_ = std::make_unique<AccessInfo>();
  }
  void delete_val() {
    return val_.reset(nullptr);
  }
  void set_val(std::unique_ptr<AccessInfo> val) {
    val_ = std::move(val);
  }
  void set_val(AccessInfo* val) {
    val_.reset(std::move(val));
  }
  AccessInfo* ptr_val() {
    #if TD_AUTO_ALLOC
    if (!has_val()) {
      alloc_val();
    }
    #endif
    #ifdef DEBUG
    if (!has_val()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return val_.get();
  }
  AccessInfo& val() {
    return *ptr_val();
  }
  const AccessInfo& val() const {
    #ifdef DEBUG
    if (!has_val()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *val_.get();
  }
  
  
  
  void set_fqn(std::vector<std::string>&& val) {
    fqn_ = std::move(val);
  }
  std::vector<std::string>& fqn() {
    return fqn_;
  }
  const std::vector<std::string>& fqn() const {
    return fqn_;
  }
  
  
  
  void set_nqn(std::vector<std::string>&& val) {
    nqn_ = std::move(val);
  }
  std::vector<std::string>& nqn() {
    return nqn_;
  }
  const std::vector<std::string>& nqn() const {
    return nqn_;
  }
  
  

 private:
  // val
  std::unique_ptr<AccessInfo> val_;
  // fqn
  std::vector<std::string> fqn_;
  // nqn
  std::vector<std::string> nqn_;
  
}; // class vector_tT



// TdType::map_tT struct declaration.
class map_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  map_tT() {}
  ~map_tT() {}

  map_tT(const map_tT&) = delete;
  map_tT& operator=(const map_tT&) = delete;
  map_tT(map_tT&&) = default;
  map_tT& operator=(map_tT&&) = default;

  

  
  
  bool has_key() const {
    return key_.operator bool();
  }
  void alloc_key() {
    key_ = std::make_unique<AccessInfo>();
  }
  void delete_key() {
    return key_.reset(nullptr);
  }
  void set_key(std::unique_ptr<AccessInfo> val) {
    key_ = std::move(val);
  }
  void set_key(AccessInfo* val) {
    key_.reset(std::move(val));
  }
  AccessInfo* ptr_key() {
    #if TD_AUTO_ALLOC
    if (!has_key()) {
      alloc_key();
    }
    #endif
    #ifdef DEBUG
    if (!has_key()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return key_.get();
  }
  AccessInfo& key() {
    return *ptr_key();
  }
  const AccessInfo& key() const {
    #ifdef DEBUG
    if (!has_key()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *key_.get();
  }
  
  
  
  bool has_val() const {
    return val_.operator bool();
  }
  void alloc_val() {
    val_ = std::make_unique<AccessInfo>();
  }
  void delete_val() {
    return val_.reset(nullptr);
  }
  void set_val(std::unique_ptr<AccessInfo> val) {
    val_ = std::move(val);
  }
  void set_val(AccessInfo* val) {
    val_.reset(std::move(val));
  }
  AccessInfo* ptr_val() {
    #if TD_AUTO_ALLOC
    if (!has_val()) {
      alloc_val();
    }
    #endif
    #ifdef DEBUG
    if (!has_val()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return val_.get();
  }
  AccessInfo& val() {
    return *ptr_val();
  }
  const AccessInfo& val() const {
    #ifdef DEBUG
    if (!has_val()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *val_.get();
  }
  
  
  
  void set_val_fqn(std::vector<std::string>&& val) {
    val_fqn_ = std::move(val);
  }
  std::vector<std::string>& val_fqn() {
    return val_fqn_;
  }
  const std::vector<std::string>& val_fqn() const {
    return val_fqn_;
  }
  
  
  
  void set_val_nqn(std::vector<std::string>&& val) {
    val_nqn_ = std::move(val);
  }
  std::vector<std::string>& val_nqn() {
    return val_nqn_;
  }
  const std::vector<std::string>& val_nqn() const {
    return val_nqn_;
  }
  
  

 private:
  // key
  std::unique_ptr<AccessInfo> key_;
  // val
  std::unique_ptr<AccessInfo> val_;
  // val_fqn
  std::vector<std::string> val_fqn_;
  // val_nqn
  std::vector<std::string> val_nqn_;
  
}; // class map_tT



// TdType::struct_tT struct declaration.
class struct_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  struct_tT() {}
  ~struct_tT() {}

  struct_tT(const struct_tT&) = delete;
  struct_tT& operator=(const struct_tT&) = delete;
  struct_tT(struct_tT&&) = default;
  struct_tT& operator=(struct_tT&&) = default;

  

  
  
  void set_fqn(std::vector<std::string>&& val) {
    fqn_ = std::move(val);
  }
  std::vector<std::string>& fqn() {
    return fqn_;
  }
  const std::vector<std::string>& fqn() const {
    return fqn_;
  }
  
  
  
  void set_nqn(std::vector<std::string>&& val) {
    nqn_ = std::move(val);
  }
  std::vector<std::string>& nqn() {
    return nqn_;
  }
  const std::vector<std::string>& nqn() const {
    return nqn_;
  }
  
  

 private:
  // fqn
  std::vector<std::string> fqn_;
  // nqn
  std::vector<std::string> nqn_;
  
}; // class struct_tT



// TdType::variant_tT struct declaration.
class variant_tT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  variant_tT() {}
  ~variant_tT() {}

  variant_tT(const variant_tT&) = delete;
  variant_tT& operator=(const variant_tT&) = delete;
  variant_tT(variant_tT&&) = default;
  variant_tT& operator=(variant_tT&&) = default;

  

  
  
  void set_fqn(std::vector<std::string>&& val) {
    fqn_ = std::move(val);
  }
  std::vector<std::string>& fqn() {
    return fqn_;
  }
  const std::vector<std::string>& fqn() const {
    return fqn_;
  }
  
  
  
  void set_nqn(std::vector<std::string>&& val) {
    nqn_ = std::move(val);
  }
  std::vector<std::string>& nqn() {
    return nqn_;
  }
  const std::vector<std::string>& nqn() const {
    return nqn_;
  }
  
  

 private:
  // fqn
  std::vector<std::string> fqn_;
  // nqn
  std::vector<std::string> nqn_;
  
}; // class variant_tT



  TdType() {}
  ~TdType() {
    tag = Tag::__TAG__UNSET;
  }

  TdType(const TdType&) = delete;
  TdType& operator=(const TdType&) = delete;
  TdType(TdType&&) = default;
  TdType& operator=(TdType&&) = default;

  

  enum class Tag {
    __TAG__UNSET = 0,
    TAG_bool_t = 1,
    TAG_char_t = 2,
    TAG_str_t = 3,
    TAG_f32_t = 4,
    TAG_f64_t = 5,
    TAG_u8_t = 6,
    TAG_u16_t = 7,
    TAG_u32_t = 8,
    TAG_u64_t = 9,
    TAG_i8_t = 10,
    TAG_i16_t = 11,
    TAG_i32_t = 12,
    TAG_i64_t = 13,
    TAG_vector_t = 14,
    TAG_map_t = 15,
    TAG_struct_t = 16,
    TAG_variant_t = 17,
    
  };
  Tag Which() const { return tag; }

  
  bool is_bool_t() const {
    return val_.index() == 1;
  }
  
  bool has_bool_t() const {
    return is_bool_t() && std::get<1>(val_).operator bool();
  }
  void alloc_bool_t() {
    tag = Tag::TAG_bool_t;
    val_.emplace<1>(std::make_unique<bool_tT>());
  }
  void delete_bool_t() {
    return std::get<1>(val_).reset(nullptr);
  }
  void set_bool_t(std::unique_ptr<bool_tT> val) {
    tag = Tag::TAG_bool_t;
    val_.emplace<1>(std::move(val));
  }
  void set_bool_t(bool_tT* val) {
    tag = Tag::TAG_bool_t;
    std::get<1>(val_).reset(std::move(val));
  }
  bool_tT* ptr_bool_t() {
    #if TD_AUTO_ALLOC
    if (!has_bool_t()) {
      alloc_bool_t();
    }
    #endif
    return std::get<1>(val_).get();
  }
  bool_tT& bool_t() {
    return *ptr_bool_t();
  }
  const bool_tT& bool_t() const {
    return *std::get<1>(val_).get();
  }
  
  bool is_char_t() const {
    return val_.index() == 2;
  }
  
  bool has_char_t() const {
    return is_char_t() && std::get<2>(val_).operator bool();
  }
  void alloc_char_t() {
    tag = Tag::TAG_char_t;
    val_.emplace<2>(std::make_unique<char_tT>());
  }
  void delete_char_t() {
    return std::get<2>(val_).reset(nullptr);
  }
  void set_char_t(std::unique_ptr<char_tT> val) {
    tag = Tag::TAG_char_t;
    val_.emplace<2>(std::move(val));
  }
  void set_char_t(char_tT* val) {
    tag = Tag::TAG_char_t;
    std::get<2>(val_).reset(std::move(val));
  }
  char_tT* ptr_char_t() {
    #if TD_AUTO_ALLOC
    if (!has_char_t()) {
      alloc_char_t();
    }
    #endif
    return std::get<2>(val_).get();
  }
  char_tT& char_t() {
    return *ptr_char_t();
  }
  const char_tT& char_t() const {
    return *std::get<2>(val_).get();
  }
  
  bool is_str_t() const {
    return val_.index() == 3;
  }
  
  bool has_str_t() const {
    return is_str_t() && std::get<3>(val_).operator bool();
  }
  void alloc_str_t() {
    tag = Tag::TAG_str_t;
    val_.emplace<3>(std::make_unique<str_tT>());
  }
  void delete_str_t() {
    return std::get<3>(val_).reset(nullptr);
  }
  void set_str_t(std::unique_ptr<str_tT> val) {
    tag = Tag::TAG_str_t;
    val_.emplace<3>(std::move(val));
  }
  void set_str_t(str_tT* val) {
    tag = Tag::TAG_str_t;
    std::get<3>(val_).reset(std::move(val));
  }
  str_tT* ptr_str_t() {
    #if TD_AUTO_ALLOC
    if (!has_str_t()) {
      alloc_str_t();
    }
    #endif
    return std::get<3>(val_).get();
  }
  str_tT& str_t() {
    return *ptr_str_t();
  }
  const str_tT& str_t() const {
    return *std::get<3>(val_).get();
  }
  
  bool is_f32_t() const {
    return val_.index() == 4;
  }
  
  bool has_f32_t() const {
    return is_f32_t() && std::get<4>(val_).operator bool();
  }
  void alloc_f32_t() {
    tag = Tag::TAG_f32_t;
    val_.emplace<4>(std::make_unique<f32_tT>());
  }
  void delete_f32_t() {
    return std::get<4>(val_).reset(nullptr);
  }
  void set_f32_t(std::unique_ptr<f32_tT> val) {
    tag = Tag::TAG_f32_t;
    val_.emplace<4>(std::move(val));
  }
  void set_f32_t(f32_tT* val) {
    tag = Tag::TAG_f32_t;
    std::get<4>(val_).reset(std::move(val));
  }
  f32_tT* ptr_f32_t() {
    #if TD_AUTO_ALLOC
    if (!has_f32_t()) {
      alloc_f32_t();
    }
    #endif
    return std::get<4>(val_).get();
  }
  f32_tT& f32_t() {
    return *ptr_f32_t();
  }
  const f32_tT& f32_t() const {
    return *std::get<4>(val_).get();
  }
  
  bool is_f64_t() const {
    return val_.index() == 5;
  }
  
  bool has_f64_t() const {
    return is_f64_t() && std::get<5>(val_).operator bool();
  }
  void alloc_f64_t() {
    tag = Tag::TAG_f64_t;
    val_.emplace<5>(std::make_unique<f64_tT>());
  }
  void delete_f64_t() {
    return std::get<5>(val_).reset(nullptr);
  }
  void set_f64_t(std::unique_ptr<f64_tT> val) {
    tag = Tag::TAG_f64_t;
    val_.emplace<5>(std::move(val));
  }
  void set_f64_t(f64_tT* val) {
    tag = Tag::TAG_f64_t;
    std::get<5>(val_).reset(std::move(val));
  }
  f64_tT* ptr_f64_t() {
    #if TD_AUTO_ALLOC
    if (!has_f64_t()) {
      alloc_f64_t();
    }
    #endif
    return std::get<5>(val_).get();
  }
  f64_tT& f64_t() {
    return *ptr_f64_t();
  }
  const f64_tT& f64_t() const {
    return *std::get<5>(val_).get();
  }
  
  bool is_u8_t() const {
    return val_.index() == 6;
  }
  
  bool has_u8_t() const {
    return is_u8_t() && std::get<6>(val_).operator bool();
  }
  void alloc_u8_t() {
    tag = Tag::TAG_u8_t;
    val_.emplace<6>(std::make_unique<u8_tT>());
  }
  void delete_u8_t() {
    return std::get<6>(val_).reset(nullptr);
  }
  void set_u8_t(std::unique_ptr<u8_tT> val) {
    tag = Tag::TAG_u8_t;
    val_.emplace<6>(std::move(val));
  }
  void set_u8_t(u8_tT* val) {
    tag = Tag::TAG_u8_t;
    std::get<6>(val_).reset(std::move(val));
  }
  u8_tT* ptr_u8_t() {
    #if TD_AUTO_ALLOC
    if (!has_u8_t()) {
      alloc_u8_t();
    }
    #endif
    return std::get<6>(val_).get();
  }
  u8_tT& u8_t() {
    return *ptr_u8_t();
  }
  const u8_tT& u8_t() const {
    return *std::get<6>(val_).get();
  }
  
  bool is_u16_t() const {
    return val_.index() == 7;
  }
  
  bool has_u16_t() const {
    return is_u16_t() && std::get<7>(val_).operator bool();
  }
  void alloc_u16_t() {
    tag = Tag::TAG_u16_t;
    val_.emplace<7>(std::make_unique<u16_tT>());
  }
  void delete_u16_t() {
    return std::get<7>(val_).reset(nullptr);
  }
  void set_u16_t(std::unique_ptr<u16_tT> val) {
    tag = Tag::TAG_u16_t;
    val_.emplace<7>(std::move(val));
  }
  void set_u16_t(u16_tT* val) {
    tag = Tag::TAG_u16_t;
    std::get<7>(val_).reset(std::move(val));
  }
  u16_tT* ptr_u16_t() {
    #if TD_AUTO_ALLOC
    if (!has_u16_t()) {
      alloc_u16_t();
    }
    #endif
    return std::get<7>(val_).get();
  }
  u16_tT& u16_t() {
    return *ptr_u16_t();
  }
  const u16_tT& u16_t() const {
    return *std::get<7>(val_).get();
  }
  
  bool is_u32_t() const {
    return val_.index() == 8;
  }
  
  bool has_u32_t() const {
    return is_u32_t() && std::get<8>(val_).operator bool();
  }
  void alloc_u32_t() {
    tag = Tag::TAG_u32_t;
    val_.emplace<8>(std::make_unique<u32_tT>());
  }
  void delete_u32_t() {
    return std::get<8>(val_).reset(nullptr);
  }
  void set_u32_t(std::unique_ptr<u32_tT> val) {
    tag = Tag::TAG_u32_t;
    val_.emplace<8>(std::move(val));
  }
  void set_u32_t(u32_tT* val) {
    tag = Tag::TAG_u32_t;
    std::get<8>(val_).reset(std::move(val));
  }
  u32_tT* ptr_u32_t() {
    #if TD_AUTO_ALLOC
    if (!has_u32_t()) {
      alloc_u32_t();
    }
    #endif
    return std::get<8>(val_).get();
  }
  u32_tT& u32_t() {
    return *ptr_u32_t();
  }
  const u32_tT& u32_t() const {
    return *std::get<8>(val_).get();
  }
  
  bool is_u64_t() const {
    return val_.index() == 9;
  }
  
  bool has_u64_t() const {
    return is_u64_t() && std::get<9>(val_).operator bool();
  }
  void alloc_u64_t() {
    tag = Tag::TAG_u64_t;
    val_.emplace<9>(std::make_unique<u64_tT>());
  }
  void delete_u64_t() {
    return std::get<9>(val_).reset(nullptr);
  }
  void set_u64_t(std::unique_ptr<u64_tT> val) {
    tag = Tag::TAG_u64_t;
    val_.emplace<9>(std::move(val));
  }
  void set_u64_t(u64_tT* val) {
    tag = Tag::TAG_u64_t;
    std::get<9>(val_).reset(std::move(val));
  }
  u64_tT* ptr_u64_t() {
    #if TD_AUTO_ALLOC
    if (!has_u64_t()) {
      alloc_u64_t();
    }
    #endif
    return std::get<9>(val_).get();
  }
  u64_tT& u64_t() {
    return *ptr_u64_t();
  }
  const u64_tT& u64_t() const {
    return *std::get<9>(val_).get();
  }
  
  bool is_i8_t() const {
    return val_.index() == 10;
  }
  
  bool has_i8_t() const {
    return is_i8_t() && std::get<10>(val_).operator bool();
  }
  void alloc_i8_t() {
    tag = Tag::TAG_i8_t;
    val_.emplace<10>(std::make_unique<i8_tT>());
  }
  void delete_i8_t() {
    return std::get<10>(val_).reset(nullptr);
  }
  void set_i8_t(std::unique_ptr<i8_tT> val) {
    tag = Tag::TAG_i8_t;
    val_.emplace<10>(std::move(val));
  }
  void set_i8_t(i8_tT* val) {
    tag = Tag::TAG_i8_t;
    std::get<10>(val_).reset(std::move(val));
  }
  i8_tT* ptr_i8_t() {
    #if TD_AUTO_ALLOC
    if (!has_i8_t()) {
      alloc_i8_t();
    }
    #endif
    return std::get<10>(val_).get();
  }
  i8_tT& i8_t() {
    return *ptr_i8_t();
  }
  const i8_tT& i8_t() const {
    return *std::get<10>(val_).get();
  }
  
  bool is_i16_t() const {
    return val_.index() == 11;
  }
  
  bool has_i16_t() const {
    return is_i16_t() && std::get<11>(val_).operator bool();
  }
  void alloc_i16_t() {
    tag = Tag::TAG_i16_t;
    val_.emplace<11>(std::make_unique<i16_tT>());
  }
  void delete_i16_t() {
    return std::get<11>(val_).reset(nullptr);
  }
  void set_i16_t(std::unique_ptr<i16_tT> val) {
    tag = Tag::TAG_i16_t;
    val_.emplace<11>(std::move(val));
  }
  void set_i16_t(i16_tT* val) {
    tag = Tag::TAG_i16_t;
    std::get<11>(val_).reset(std::move(val));
  }
  i16_tT* ptr_i16_t() {
    #if TD_AUTO_ALLOC
    if (!has_i16_t()) {
      alloc_i16_t();
    }
    #endif
    return std::get<11>(val_).get();
  }
  i16_tT& i16_t() {
    return *ptr_i16_t();
  }
  const i16_tT& i16_t() const {
    return *std::get<11>(val_).get();
  }
  
  bool is_i32_t() const {
    return val_.index() == 12;
  }
  
  bool has_i32_t() const {
    return is_i32_t() && std::get<12>(val_).operator bool();
  }
  void alloc_i32_t() {
    tag = Tag::TAG_i32_t;
    val_.emplace<12>(std::make_unique<i32_tT>());
  }
  void delete_i32_t() {
    return std::get<12>(val_).reset(nullptr);
  }
  void set_i32_t(std::unique_ptr<i32_tT> val) {
    tag = Tag::TAG_i32_t;
    val_.emplace<12>(std::move(val));
  }
  void set_i32_t(i32_tT* val) {
    tag = Tag::TAG_i32_t;
    std::get<12>(val_).reset(std::move(val));
  }
  i32_tT* ptr_i32_t() {
    #if TD_AUTO_ALLOC
    if (!has_i32_t()) {
      alloc_i32_t();
    }
    #endif
    return std::get<12>(val_).get();
  }
  i32_tT& i32_t() {
    return *ptr_i32_t();
  }
  const i32_tT& i32_t() const {
    return *std::get<12>(val_).get();
  }
  
  bool is_i64_t() const {
    return val_.index() == 13;
  }
  
  bool has_i64_t() const {
    return is_i64_t() && std::get<13>(val_).operator bool();
  }
  void alloc_i64_t() {
    tag = Tag::TAG_i64_t;
    val_.emplace<13>(std::make_unique<i64_tT>());
  }
  void delete_i64_t() {
    return std::get<13>(val_).reset(nullptr);
  }
  void set_i64_t(std::unique_ptr<i64_tT> val) {
    tag = Tag::TAG_i64_t;
    val_.emplace<13>(std::move(val));
  }
  void set_i64_t(i64_tT* val) {
    tag = Tag::TAG_i64_t;
    std::get<13>(val_).reset(std::move(val));
  }
  i64_tT* ptr_i64_t() {
    #if TD_AUTO_ALLOC
    if (!has_i64_t()) {
      alloc_i64_t();
    }
    #endif
    return std::get<13>(val_).get();
  }
  i64_tT& i64_t() {
    return *ptr_i64_t();
  }
  const i64_tT& i64_t() const {
    return *std::get<13>(val_).get();
  }
  
  bool is_vector_t() const {
    return val_.index() == 14;
  }
  
  bool has_vector_t() const {
    return is_vector_t() && std::get<14>(val_).operator bool();
  }
  void alloc_vector_t() {
    tag = Tag::TAG_vector_t;
    val_.emplace<14>(std::make_unique<vector_tT>());
  }
  void delete_vector_t() {
    return std::get<14>(val_).reset(nullptr);
  }
  void set_vector_t(std::unique_ptr<vector_tT> val) {
    tag = Tag::TAG_vector_t;
    val_.emplace<14>(std::move(val));
  }
  void set_vector_t(vector_tT* val) {
    tag = Tag::TAG_vector_t;
    std::get<14>(val_).reset(std::move(val));
  }
  vector_tT* ptr_vector_t() {
    #if TD_AUTO_ALLOC
    if (!has_vector_t()) {
      alloc_vector_t();
    }
    #endif
    return std::get<14>(val_).get();
  }
  vector_tT& vector_t() {
    return *ptr_vector_t();
  }
  const vector_tT& vector_t() const {
    return *std::get<14>(val_).get();
  }
  
  bool is_map_t() const {
    return val_.index() == 15;
  }
  
  bool has_map_t() const {
    return is_map_t() && std::get<15>(val_).operator bool();
  }
  void alloc_map_t() {
    tag = Tag::TAG_map_t;
    val_.emplace<15>(std::make_unique<map_tT>());
  }
  void delete_map_t() {
    return std::get<15>(val_).reset(nullptr);
  }
  void set_map_t(std::unique_ptr<map_tT> val) {
    tag = Tag::TAG_map_t;
    val_.emplace<15>(std::move(val));
  }
  void set_map_t(map_tT* val) {
    tag = Tag::TAG_map_t;
    std::get<15>(val_).reset(std::move(val));
  }
  map_tT* ptr_map_t() {
    #if TD_AUTO_ALLOC
    if (!has_map_t()) {
      alloc_map_t();
    }
    #endif
    return std::get<15>(val_).get();
  }
  map_tT& map_t() {
    return *ptr_map_t();
  }
  const map_tT& map_t() const {
    return *std::get<15>(val_).get();
  }
  
  bool is_struct_t() const {
    return val_.index() == 16;
  }
  
  bool has_struct_t() const {
    return is_struct_t() && std::get<16>(val_).operator bool();
  }
  void alloc_struct_t() {
    tag = Tag::TAG_struct_t;
    val_.emplace<16>(std::make_unique<struct_tT>());
  }
  void delete_struct_t() {
    return std::get<16>(val_).reset(nullptr);
  }
  void set_struct_t(std::unique_ptr<struct_tT> val) {
    tag = Tag::TAG_struct_t;
    val_.emplace<16>(std::move(val));
  }
  void set_struct_t(struct_tT* val) {
    tag = Tag::TAG_struct_t;
    std::get<16>(val_).reset(std::move(val));
  }
  struct_tT* ptr_struct_t() {
    #if TD_AUTO_ALLOC
    if (!has_struct_t()) {
      alloc_struct_t();
    }
    #endif
    return std::get<16>(val_).get();
  }
  struct_tT& struct_t() {
    return *ptr_struct_t();
  }
  const struct_tT& struct_t() const {
    return *std::get<16>(val_).get();
  }
  
  bool is_variant_t() const {
    return val_.index() == 17;
  }
  
  bool has_variant_t() const {
    return is_variant_t() && std::get<17>(val_).operator bool();
  }
  void alloc_variant_t() {
    tag = Tag::TAG_variant_t;
    val_.emplace<17>(std::make_unique<variant_tT>());
  }
  void delete_variant_t() {
    return std::get<17>(val_).reset(nullptr);
  }
  void set_variant_t(std::unique_ptr<variant_tT> val) {
    tag = Tag::TAG_variant_t;
    val_.emplace<17>(std::move(val));
  }
  void set_variant_t(variant_tT* val) {
    tag = Tag::TAG_variant_t;
    std::get<17>(val_).reset(std::move(val));
  }
  variant_tT* ptr_variant_t() {
    #if TD_AUTO_ALLOC
    if (!has_variant_t()) {
      alloc_variant_t();
    }
    #endif
    return std::get<17>(val_).get();
  }
  variant_tT& variant_t() {
    return *ptr_variant_t();
  }
  const variant_tT& variant_t() const {
    return *std::get<17>(val_).get();
  }
  

 private:
  Tag tag = Tag::__TAG__UNSET;

  std::variant<
    std::monostate
  , std::unique_ptr<bool_tT>
  , std::unique_ptr<char_tT>
  , std::unique_ptr<str_tT>
  , std::unique_ptr<f32_tT>
  , std::unique_ptr<f64_tT>
  , std::unique_ptr<u8_tT>
  , std::unique_ptr<u16_tT>
  , std::unique_ptr<u32_tT>
  , std::unique_ptr<u64_tT>
  , std::unique_ptr<i8_tT>
  , std::unique_ptr<i16_tT>
  , std::unique_ptr<i32_tT>
  , std::unique_ptr<i64_tT>
  , std::unique_ptr<vector_tT>
  , std::unique_ptr<map_tT>
  , std::unique_ptr<struct_tT>
  , std::unique_ptr<variant_tT>
  
  > val_;

};  // class TdType


// AccessInfo struct declaration.
class AccessInfo {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

// td::codegen::cpp::AccessInfo::access_byT variant declaration.
class access_byT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  access_byT() {}
  ~access_byT() {
    tag = Tag::__TAG__UNSET;
  }

  access_byT(const access_byT&) = delete;
  access_byT& operator=(const access_byT&) = delete;
  access_byT(access_byT&&) = default;
  access_byT& operator=(access_byT&&) = default;

  

  enum class Tag {
    __TAG__UNSET = 0,
    TAG_value = 1,
    TAG_reference = 2,
    TAG_pointer = 3,
    
  };
  Tag Which() const { return tag; }

  
  bool is_value() const {
    return val_.index() == 1;
  }
  
  bool get_value() const {
    return std::get<1>(val_);
  }
  void set_value(bool val) {
    tag = Tag::TAG_value;
    val_.emplace<1>(val);
  }
  bool& value() {
    if (!is_value()) {
      tag = Tag::TAG_value;
      val_.emplace<1>();
    }
    return std::get<1>(val_);
  }
  const bool& value() const {
    return std::get<1>(val_);
  }
  
  bool is_reference() const {
    return val_.index() == 2;
  }
  
  bool get_reference() const {
    return std::get<2>(val_);
  }
  void set_reference(bool val) {
    tag = Tag::TAG_reference;
    val_.emplace<2>(val);
  }
  bool& reference() {
    if (!is_reference()) {
      tag = Tag::TAG_reference;
      val_.emplace<2>();
    }
    return std::get<2>(val_);
  }
  const bool& reference() const {
    return std::get<2>(val_);
  }
  
  bool is_pointer() const {
    return val_.index() == 3;
  }
  
  bool get_pointer() const {
    return std::get<3>(val_);
  }
  void set_pointer(bool val) {
    tag = Tag::TAG_pointer;
    val_.emplace<3>(val);
  }
  bool& pointer() {
    if (!is_pointer()) {
      tag = Tag::TAG_pointer;
      val_.emplace<3>();
    }
    return std::get<3>(val_);
  }
  const bool& pointer() const {
    return std::get<3>(val_);
  }
  

 private:
  Tag tag = Tag::__TAG__UNSET;

  std::variant<
    std::monostate
  , bool
  , bool
  , bool
  
  > val_;

};  // class access_byT



  AccessInfo() {}
  ~AccessInfo() {}

  AccessInfo(const AccessInfo&) = delete;
  AccessInfo& operator=(const AccessInfo&) = delete;
  AccessInfo(AccessInfo&&) = default;
  AccessInfo& operator=(AccessInfo&&) = default;

  

  
  
  void set_identifier(std::string&& val) {
    identifier_ = std::move(val);
  }
  std::string& identifier() {
    return identifier_;
  }
  const std::string& identifier() const {
    return identifier_;
  }
  
  
  
  bool has_td_type() const {
    return td_type_.operator bool();
  }
  void alloc_td_type() {
    td_type_ = std::make_unique<TdType>();
  }
  void delete_td_type() {
    return td_type_.reset(nullptr);
  }
  void set_td_type(std::unique_ptr<TdType> val) {
    td_type_ = std::move(val);
  }
  void set_td_type(TdType* val) {
    td_type_.reset(std::move(val));
  }
  TdType* ptr_td_type() {
    #if TD_AUTO_ALLOC
    if (!has_td_type()) {
      alloc_td_type();
    }
    #endif
    #ifdef DEBUG
    if (!has_td_type()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return td_type_.get();
  }
  TdType& td_type() {
    return *ptr_td_type();
  }
  const TdType& td_type() const {
    #ifdef DEBUG
    if (!has_td_type()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *td_type_.get();
  }
  
  
  
  void set_cpp_type(std::string&& val) {
    cpp_type_ = std::move(val);
  }
  std::string& cpp_type() {
    return cpp_type_;
  }
  const std::string& cpp_type() const {
    return cpp_type_;
  }
  
  
  
  bool has_access_by() const {
    return access_by_.operator bool();
  }
  void alloc_access_by() {
    access_by_ = std::make_unique<access_byT>();
  }
  void delete_access_by() {
    return access_by_.reset(nullptr);
  }
  void set_access_by(std::unique_ptr<access_byT> val) {
    access_by_ = std::move(val);
  }
  void set_access_by(access_byT* val) {
    access_by_.reset(std::move(val));
  }
  access_byT* ptr_access_by() {
    #if TD_AUTO_ALLOC
    if (!has_access_by()) {
      alloc_access_by();
    }
    #endif
    #ifdef DEBUG
    if (!has_access_by()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return access_by_.get();
  }
  access_byT& access_by() {
    return *ptr_access_by();
  }
  const access_byT& access_by() const {
    #ifdef DEBUG
    if (!has_access_by()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *access_by_.get();
  }
  
  
  
  bool get_is_required() const {
    return is_required_;
  }
  void set_is_required(bool val) {
    is_required_ = val;
  }
  bool& is_required() {
    return is_required_;
  }
  const bool& is_required() const {
    return is_required_;
  }
  
  
  
  void set_type_arguments(std::vector<AccessInfo>&& val) {
    type_arguments_ = std::move(val);
  }
  std::vector<AccessInfo>& type_arguments() {
    return type_arguments_;
  }
  const std::vector<AccessInfo>& type_arguments() const {
    return type_arguments_;
  }
  
  

 private:
  // identifier
  std::string identifier_ = "";
  // td_type
  std::unique_ptr<TdType> td_type_;
  // cpp_type
  std::string cpp_type_ = "";
  // access_by
  std::unique_ptr<access_byT> access_by_;
  // is_required
  bool is_required_ = 0;
  // type_arguments
  std::vector<AccessInfo> type_arguments_;
  
}; // class AccessInfo


// StructDecl struct declaration.
class StructDecl {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  StructDecl() {}
  ~StructDecl() {}

  StructDecl(const StructDecl&) = delete;
  StructDecl& operator=(const StructDecl&) = delete;
  StructDecl(StructDecl&&) = default;
  StructDecl& operator=(StructDecl&&) = default;

  

  
  
  void set_identifier(std::string&& val) {
    identifier_ = std::move(val);
  }
  std::string& identifier() {
    return identifier_;
  }
  const std::string& identifier() const {
    return identifier_;
  }
  
  
  
  void set_fqn(std::vector<std::string>&& val) {
    fqn_ = std::move(val);
  }
  std::vector<std::string>& fqn() {
    return fqn_;
  }
  const std::vector<std::string>& fqn() const {
    return fqn_;
  }
  
  
  
  void set_nqn(std::vector<std::string>&& val) {
    nqn_ = std::move(val);
  }
  std::vector<std::string>& nqn() {
    return nqn_;
  }
  const std::vector<std::string>& nqn() const {
    return nqn_;
  }
  
  
  
  void set_nested_type_decls(std::vector<UserTypeDeclaration>&& val) {
    nested_type_decls_ = std::move(val);
  }
  std::vector<UserTypeDeclaration>& nested_type_decls() {
    return nested_type_decls_;
  }
  const std::vector<UserTypeDeclaration>& nested_type_decls() const {
    return nested_type_decls_;
  }
  
  
  
  void set_inline_type_decls(std::vector<UserTypeDeclaration>&& val) {
    inline_type_decls_ = std::move(val);
  }
  std::vector<UserTypeDeclaration>& inline_type_decls() {
    return inline_type_decls_;
  }
  const std::vector<UserTypeDeclaration>& inline_type_decls() const {
    return inline_type_decls_;
  }
  
  
  
  void set_fields(std::vector<AccessInfo>&& val) {
    fields_ = std::move(val);
  }
  std::vector<AccessInfo>& fields() {
    return fields_;
  }
  const std::vector<AccessInfo>& fields() const {
    return fields_;
  }
  
  

 private:
  // identifier
  std::string identifier_ = "";
  // fqn
  std::vector<std::string> fqn_;
  // nqn
  std::vector<std::string> nqn_;
  // nested_type_decls
  std::vector<UserTypeDeclaration> nested_type_decls_;
  // inline_type_decls
  std::vector<UserTypeDeclaration> inline_type_decls_;
  // fields
  std::vector<AccessInfo> fields_;
  
}; // class StructDecl


// td::codegen::cpp::UserTypeDeclaration variant declaration.
class UserTypeDeclaration {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  UserTypeDeclaration() {}
  ~UserTypeDeclaration() {
    tag = Tag::__TAG__UNSET;
  }

  UserTypeDeclaration(const UserTypeDeclaration&) = delete;
  UserTypeDeclaration& operator=(const UserTypeDeclaration&) = delete;
  UserTypeDeclaration(UserTypeDeclaration&&) = default;
  UserTypeDeclaration& operator=(UserTypeDeclaration&&) = default;

  

  enum class Tag {
    __TAG__UNSET = 0,
    TAG_struct_decl = 1,
    TAG_variant_decl = 2,
    
  };
  Tag Which() const { return tag; }

  
  bool is_struct_decl() const {
    return val_.index() == 1;
  }
  
  bool has_struct_decl() const {
    return is_struct_decl() && std::get<1>(val_).operator bool();
  }
  void alloc_struct_decl() {
    tag = Tag::TAG_struct_decl;
    val_.emplace<1>(std::make_unique<StructDecl>());
  }
  void delete_struct_decl() {
    return std::get<1>(val_).reset(nullptr);
  }
  void set_struct_decl(std::unique_ptr<StructDecl> val) {
    tag = Tag::TAG_struct_decl;
    val_.emplace<1>(std::move(val));
  }
  void set_struct_decl(StructDecl* val) {
    tag = Tag::TAG_struct_decl;
    std::get<1>(val_).reset(std::move(val));
  }
  StructDecl* ptr_struct_decl() {
    #if TD_AUTO_ALLOC
    if (!has_struct_decl()) {
      alloc_struct_decl();
    }
    #endif
    return std::get<1>(val_).get();
  }
  StructDecl& struct_decl() {
    return *ptr_struct_decl();
  }
  const StructDecl& struct_decl() const {
    return *std::get<1>(val_).get();
  }
  
  bool is_variant_decl() const {
    return val_.index() == 2;
  }
  
  bool has_variant_decl() const {
    return is_variant_decl() && std::get<2>(val_).operator bool();
  }
  void alloc_variant_decl() {
    tag = Tag::TAG_variant_decl;
    val_.emplace<2>(std::make_unique<StructDecl>());
  }
  void delete_variant_decl() {
    return std::get<2>(val_).reset(nullptr);
  }
  void set_variant_decl(std::unique_ptr<StructDecl> val) {
    tag = Tag::TAG_variant_decl;
    val_.emplace<2>(std::move(val));
  }
  void set_variant_decl(StructDecl* val) {
    tag = Tag::TAG_variant_decl;
    std::get<2>(val_).reset(std::move(val));
  }
  StructDecl* ptr_variant_decl() {
    #if TD_AUTO_ALLOC
    if (!has_variant_decl()) {
      alloc_variant_decl();
    }
    #endif
    return std::get<2>(val_).get();
  }
  StructDecl& variant_decl() {
    return *ptr_variant_decl();
  }
  const StructDecl& variant_decl() const {
    return *std::get<2>(val_).get();
  }
  

 private:
  Tag tag = Tag::__TAG__UNSET;

  std::variant<
    std::monostate
  , std::unique_ptr<StructDecl>
  , std::unique_ptr<StructDecl>
  
  > val_;

};  // class UserTypeDeclaration


// TmplValueDereference struct declaration.
class TmplValueDereference {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  TmplValueDereference() {}
  ~TmplValueDereference() {}

  TmplValueDereference(const TmplValueDereference&) = delete;
  TmplValueDereference& operator=(const TmplValueDereference&) = delete;
  TmplValueDereference(TmplValueDereference&&) = default;
  TmplValueDereference& operator=(TmplValueDereference&&) = default;

  

  
  
  void set_val_ref_path(std::vector<std::string>&& val) {
    val_ref_path_ = std::move(val);
  }
  std::vector<std::string>& val_ref_path() {
    return val_ref_path_;
  }
  const std::vector<std::string>& val_ref_path() const {
    return val_ref_path_;
  }
  
  
  
  bool has_access_info() const {
    return access_info_.operator bool();
  }
  void alloc_access_info() {
    access_info_ = std::make_unique<AccessInfo>();
  }
  void delete_access_info() {
    return access_info_.reset(nullptr);
  }
  void set_access_info(std::unique_ptr<AccessInfo> val) {
    access_info_ = std::move(val);
  }
  void set_access_info(AccessInfo* val) {
    access_info_.reset(std::move(val));
  }
  AccessInfo* ptr_access_info() {
    #if TD_AUTO_ALLOC
    if (!has_access_info()) {
      alloc_access_info();
    }
    #endif
    #ifdef DEBUG
    if (!has_access_info()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return access_info_.get();
  }
  AccessInfo& access_info() {
    return *ptr_access_info();
  }
  const AccessInfo& access_info() const {
    #ifdef DEBUG
    if (!has_access_info()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *access_info_.get();
  }
  
  

 private:
  // val_ref_path
  std::vector<std::string> val_ref_path_;
  // access_info
  std::unique_ptr<AccessInfo> access_info_;
  
}; // class TmplValueDereference


// TmplFuncCall struct declaration.
class TmplFuncCall {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  TmplFuncCall() {}
  ~TmplFuncCall() {}

  TmplFuncCall(const TmplFuncCall&) = delete;
  TmplFuncCall& operator=(const TmplFuncCall&) = delete;
  TmplFuncCall(TmplFuncCall&&) = default;
  TmplFuncCall& operator=(TmplFuncCall&&) = default;

  

  
  
  void set_identifier(std::string&& val) {
    identifier_ = std::move(val);
  }
  std::string& identifier() {
    return identifier_;
  }
  const std::string& identifier() const {
    return identifier_;
  }
  
  
  
  void set_args(std::vector<TmplExpression>&& val) {
    args_ = std::move(val);
  }
  std::vector<TmplExpression>& args() {
    return args_;
  }
  const std::vector<TmplExpression>& args() const {
    return args_;
  }
  
  

 private:
  // identifier
  std::string identifier_ = "";
  // args
  std::vector<TmplExpression> args_;
  
}; // class TmplFuncCall


// td::codegen::cpp::TmplExpression variant declaration.
class TmplExpression {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  TmplExpression() {}
  ~TmplExpression() {
    tag = Tag::__TAG__UNSET;
  }

  TmplExpression(const TmplExpression&) = delete;
  TmplExpression& operator=(const TmplExpression&) = delete;
  TmplExpression(TmplExpression&&) = default;
  TmplExpression& operator=(TmplExpression&&) = default;

  

  enum class Tag {
    __TAG__UNSET = 0,
    TAG_call = 1,
    TAG_val_ref = 2,
    TAG_expr = 3,
    TAG_not_expr = 4,
    
  };
  Tag Which() const { return tag; }

  
  bool is_call() const {
    return val_.index() == 1;
  }
  
  bool has_call() const {
    return is_call() && std::get<1>(val_).operator bool();
  }
  void alloc_call() {
    tag = Tag::TAG_call;
    val_.emplace<1>(std::make_unique<TmplFuncCall>());
  }
  void delete_call() {
    return std::get<1>(val_).reset(nullptr);
  }
  void set_call(std::unique_ptr<TmplFuncCall> val) {
    tag = Tag::TAG_call;
    val_.emplace<1>(std::move(val));
  }
  void set_call(TmplFuncCall* val) {
    tag = Tag::TAG_call;
    std::get<1>(val_).reset(std::move(val));
  }
  TmplFuncCall* ptr_call() {
    #if TD_AUTO_ALLOC
    if (!has_call()) {
      alloc_call();
    }
    #endif
    return std::get<1>(val_).get();
  }
  TmplFuncCall& call() {
    return *ptr_call();
  }
  const TmplFuncCall& call() const {
    return *std::get<1>(val_).get();
  }
  
  bool is_val_ref() const {
    return val_.index() == 2;
  }
  
  bool has_val_ref() const {
    return is_val_ref() && std::get<2>(val_).operator bool();
  }
  void alloc_val_ref() {
    tag = Tag::TAG_val_ref;
    val_.emplace<2>(std::make_unique<TmplValueDereference>());
  }
  void delete_val_ref() {
    return std::get<2>(val_).reset(nullptr);
  }
  void set_val_ref(std::unique_ptr<TmplValueDereference> val) {
    tag = Tag::TAG_val_ref;
    val_.emplace<2>(std::move(val));
  }
  void set_val_ref(TmplValueDereference* val) {
    tag = Tag::TAG_val_ref;
    std::get<2>(val_).reset(std::move(val));
  }
  TmplValueDereference* ptr_val_ref() {
    #if TD_AUTO_ALLOC
    if (!has_val_ref()) {
      alloc_val_ref();
    }
    #endif
    return std::get<2>(val_).get();
  }
  TmplValueDereference& val_ref() {
    return *ptr_val_ref();
  }
  const TmplValueDereference& val_ref() const {
    return *std::get<2>(val_).get();
  }
  
  bool is_expr() const {
    return val_.index() == 3;
  }
  
  bool has_expr() const {
    return is_expr() && std::get<3>(val_).operator bool();
  }
  void alloc_expr() {
    tag = Tag::TAG_expr;
    val_.emplace<3>(std::make_unique<TmplExpression>());
  }
  void delete_expr() {
    return std::get<3>(val_).reset(nullptr);
  }
  void set_expr(std::unique_ptr<TmplExpression> val) {
    tag = Tag::TAG_expr;
    val_.emplace<3>(std::move(val));
  }
  void set_expr(TmplExpression* val) {
    tag = Tag::TAG_expr;
    std::get<3>(val_).reset(std::move(val));
  }
  TmplExpression* ptr_expr() {
    #if TD_AUTO_ALLOC
    if (!has_expr()) {
      alloc_expr();
    }
    #endif
    return std::get<3>(val_).get();
  }
  TmplExpression& expr() {
    return *ptr_expr();
  }
  const TmplExpression& expr() const {
    return *std::get<3>(val_).get();
  }
  
  bool is_not_expr() const {
    return val_.index() == 4;
  }
  
  bool has_not_expr() const {
    return is_not_expr() && std::get<4>(val_).operator bool();
  }
  void alloc_not_expr() {
    tag = Tag::TAG_not_expr;
    val_.emplace<4>(std::make_unique<TmplExpression>());
  }
  void delete_not_expr() {
    return std::get<4>(val_).reset(nullptr);
  }
  void set_not_expr(std::unique_ptr<TmplExpression> val) {
    tag = Tag::TAG_not_expr;
    val_.emplace<4>(std::move(val));
  }
  void set_not_expr(TmplExpression* val) {
    tag = Tag::TAG_not_expr;
    std::get<4>(val_).reset(std::move(val));
  }
  TmplExpression* ptr_not_expr() {
    #if TD_AUTO_ALLOC
    if (!has_not_expr()) {
      alloc_not_expr();
    }
    #endif
    return std::get<4>(val_).get();
  }
  TmplExpression& not_expr() {
    return *ptr_not_expr();
  }
  const TmplExpression& not_expr() const {
    return *std::get<4>(val_).get();
  }
  

 private:
  Tag tag = Tag::__TAG__UNSET;

  std::variant<
    std::monostate
  , std::unique_ptr<TmplFuncCall>
  , std::unique_ptr<TmplValueDereference>
  , std::unique_ptr<TmplExpression>
  , std::unique_ptr<TmplExpression>
  
  > val_;

};  // class TmplExpression


// TmplIf struct declaration.
class TmplIf {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  TmplIf() {}
  ~TmplIf() {}

  TmplIf(const TmplIf&) = delete;
  TmplIf& operator=(const TmplIf&) = delete;
  TmplIf(TmplIf&&) = default;
  TmplIf& operator=(TmplIf&&) = default;

  

  
  
  bool has_expr() const {
    return expr_.operator bool();
  }
  void alloc_expr() {
    expr_ = std::make_unique<TmplExpression>();
  }
  void delete_expr() {
    return expr_.reset(nullptr);
  }
  void set_expr(std::unique_ptr<TmplExpression> val) {
    expr_ = std::move(val);
  }
  void set_expr(TmplExpression* val) {
    expr_.reset(std::move(val));
  }
  TmplExpression* ptr_expr() {
    #if TD_AUTO_ALLOC
    if (!has_expr()) {
      alloc_expr();
    }
    #endif
    #ifdef DEBUG
    if (!has_expr()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return expr_.get();
  }
  TmplExpression& expr() {
    return *ptr_expr();
  }
  const TmplExpression& expr() const {
    #ifdef DEBUG
    if (!has_expr()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *expr_.get();
  }
  
  
  
  void set_items(std::vector<TmplItem>&& val) {
    items_ = std::move(val);
  }
  std::vector<TmplItem>& items() {
    return items_;
  }
  const std::vector<TmplItem>& items() const {
    return items_;
  }
  
  

 private:
  // expr
  std::unique_ptr<TmplExpression> expr_;
  // items
  std::vector<TmplItem> items_;
  
}; // class TmplIf


// TmplIfBlock struct declaration.
class TmplIfBlock {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  TmplIfBlock() {}
  ~TmplIfBlock() {}

  TmplIfBlock(const TmplIfBlock&) = delete;
  TmplIfBlock& operator=(const TmplIfBlock&) = delete;
  TmplIfBlock(TmplIfBlock&&) = default;
  TmplIfBlock& operator=(TmplIfBlock&&) = default;

  

  
  
  bool has_if_sublock() const {
    return if_sublock_.operator bool();
  }
  void alloc_if_sublock() {
    if_sublock_ = std::make_unique<TmplIf>();
  }
  void delete_if_sublock() {
    return if_sublock_.reset(nullptr);
  }
  void set_if_sublock(std::unique_ptr<TmplIf> val) {
    if_sublock_ = std::move(val);
  }
  void set_if_sublock(TmplIf* val) {
    if_sublock_.reset(std::move(val));
  }
  TmplIf* ptr_if_sublock() {
    #if TD_AUTO_ALLOC
    if (!has_if_sublock()) {
      alloc_if_sublock();
    }
    #endif
    #ifdef DEBUG
    if (!has_if_sublock()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return if_sublock_.get();
  }
  TmplIf& if_sublock() {
    return *ptr_if_sublock();
  }
  const TmplIf& if_sublock() const {
    #ifdef DEBUG
    if (!has_if_sublock()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *if_sublock_.get();
  }
  
  
  
  void set_elifs(std::vector<TmplIf>&& val) {
    elifs_ = std::move(val);
  }
  std::vector<TmplIf>& elifs() {
    return elifs_;
  }
  const std::vector<TmplIf>& elifs() const {
    return elifs_;
  }
  
  
  
  void set_else_items(std::vector<TmplItem>&& val) {
    else_items_ = std::move(val);
  }
  std::vector<TmplItem>& else_items() {
    return else_items_;
  }
  const std::vector<TmplItem>& else_items() const {
    return else_items_;
  }
  
  

 private:
  // if_sublock
  std::unique_ptr<TmplIf> if_sublock_;
  // elifs
  std::vector<TmplIf> elifs_;
  // else_items
  std::vector<TmplItem> else_items_;
  
}; // class TmplIfBlock


// TmplForBlock struct declaration.
class TmplForBlock {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

// td::codegen::cpp::TmplForBlock::binding_varsT variant declaration.
class binding_varsT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

// TmplForBlock::binding_varsT::key_valT struct declaration.
class key_valT {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  key_valT() {}
  ~key_valT() {}

  key_valT(const key_valT&) = delete;
  key_valT& operator=(const key_valT&) = delete;
  key_valT(key_valT&&) = default;
  key_valT& operator=(key_valT&&) = default;

  

  
  
  void set_key(std::string&& val) {
    key_ = std::move(val);
  }
  std::string& key() {
    return key_;
  }
  const std::string& key() const {
    return key_;
  }
  
  
  
  void set_val(std::string&& val) {
    val_ = std::move(val);
  }
  std::string& val() {
    return val_;
  }
  const std::string& val() const {
    return val_;
  }
  
  

 private:
  // key
  std::string key_ = "";
  // val
  std::string val_ = "";
  
}; // class key_valT



  binding_varsT() {}
  ~binding_varsT() {
    tag = Tag::__TAG__UNSET;
  }

  binding_varsT(const binding_varsT&) = delete;
  binding_varsT& operator=(const binding_varsT&) = delete;
  binding_varsT(binding_varsT&&) = default;
  binding_varsT& operator=(binding_varsT&&) = default;

  

  enum class Tag {
    __TAG__UNSET = 0,
    TAG_var = 1,
    TAG_key_val = 2,
    
  };
  Tag Which() const { return tag; }

  
  bool is_var() const {
    return val_.index() == 1;
  }
  
  std::string& var() {
    if (!is_var()) {
      tag = Tag::TAG_var;
      val_.emplace<1>();
    }
    return std::get<1>(val_);
  }
  const std::string& var() const {
    return std::get<1>(val_);
  }
  void set_var(std::string&& val) {
    tag = Tag::TAG_var;
    val_.emplace<1>(std::move(val));
  }
  
  bool is_key_val() const {
    return val_.index() == 2;
  }
  
  bool has_key_val() const {
    return is_key_val() && std::get<2>(val_).operator bool();
  }
  void alloc_key_val() {
    tag = Tag::TAG_key_val;
    val_.emplace<2>(std::make_unique<key_valT>());
  }
  void delete_key_val() {
    return std::get<2>(val_).reset(nullptr);
  }
  void set_key_val(std::unique_ptr<key_valT> val) {
    tag = Tag::TAG_key_val;
    val_.emplace<2>(std::move(val));
  }
  void set_key_val(key_valT* val) {
    tag = Tag::TAG_key_val;
    std::get<2>(val_).reset(std::move(val));
  }
  key_valT* ptr_key_val() {
    #if TD_AUTO_ALLOC
    if (!has_key_val()) {
      alloc_key_val();
    }
    #endif
    return std::get<2>(val_).get();
  }
  key_valT& key_val() {
    return *ptr_key_val();
  }
  const key_valT& key_val() const {
    return *std::get<2>(val_).get();
  }
  

 private:
  Tag tag = Tag::__TAG__UNSET;

  std::variant<
    std::monostate
  , std::string
  , std::unique_ptr<key_valT>
  
  > val_;

};  // class binding_varsT



  TmplForBlock() {}
  ~TmplForBlock() {}

  TmplForBlock(const TmplForBlock&) = delete;
  TmplForBlock& operator=(const TmplForBlock&) = delete;
  TmplForBlock(TmplForBlock&&) = default;
  TmplForBlock& operator=(TmplForBlock&&) = default;

  

  
  
  bool has_binding_vars() const {
    return binding_vars_.operator bool();
  }
  void alloc_binding_vars() {
    binding_vars_ = std::make_unique<binding_varsT>();
  }
  void delete_binding_vars() {
    return binding_vars_.reset(nullptr);
  }
  void set_binding_vars(std::unique_ptr<binding_varsT> val) {
    binding_vars_ = std::move(val);
  }
  void set_binding_vars(binding_varsT* val) {
    binding_vars_.reset(std::move(val));
  }
  binding_varsT* ptr_binding_vars() {
    #if TD_AUTO_ALLOC
    if (!has_binding_vars()) {
      alloc_binding_vars();
    }
    #endif
    #ifdef DEBUG
    if (!has_binding_vars()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return binding_vars_.get();
  }
  binding_varsT& binding_vars() {
    return *ptr_binding_vars();
  }
  const binding_varsT& binding_vars() const {
    #ifdef DEBUG
    if (!has_binding_vars()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *binding_vars_.get();
  }
  
  
  
  bool has_collection() const {
    return collection_.operator bool();
  }
  void alloc_collection() {
    collection_ = std::make_unique<TmplValueDereference>();
  }
  void delete_collection() {
    return collection_.reset(nullptr);
  }
  void set_collection(std::unique_ptr<TmplValueDereference> val) {
    collection_ = std::move(val);
  }
  void set_collection(TmplValueDereference* val) {
    collection_.reset(std::move(val));
  }
  TmplValueDereference* ptr_collection() {
    #if TD_AUTO_ALLOC
    if (!has_collection()) {
      alloc_collection();
    }
    #endif
    #ifdef DEBUG
    if (!has_collection()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return collection_.get();
  }
  TmplValueDereference& collection() {
    return *ptr_collection();
  }
  const TmplValueDereference& collection() const {
    #ifdef DEBUG
    if (!has_collection()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *collection_.get();
  }
  
  
  
  void set_items(std::vector<TmplItem>&& val) {
    items_ = std::move(val);
  }
  std::vector<TmplItem>& items() {
    return items_;
  }
  const std::vector<TmplItem>& items() const {
    return items_;
  }
  
  

 private:
  // binding_vars
  std::unique_ptr<binding_varsT> binding_vars_;
  // collection
  std::unique_ptr<TmplValueDereference> collection_;
  // items
  std::vector<TmplItem> items_;
  
}; // class TmplForBlock


// SwitchCase struct declaration.
class SwitchCase {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  SwitchCase() {}
  ~SwitchCase() {}

  SwitchCase(const SwitchCase&) = delete;
  SwitchCase& operator=(const SwitchCase&) = delete;
  SwitchCase(SwitchCase&&) = default;
  SwitchCase& operator=(SwitchCase&&) = default;

  

  
  
  bool has_label() const {
    return label_.operator bool();
  }
  void alloc_label() {
    label_ = std::make_unique<TmplValueDereference>();
  }
  void delete_label() {
    return label_.reset(nullptr);
  }
  void set_label(std::unique_ptr<TmplValueDereference> val) {
    label_ = std::move(val);
  }
  void set_label(TmplValueDereference* val) {
    label_.reset(std::move(val));
  }
  TmplValueDereference* ptr_label() {
    #if TD_AUTO_ALLOC
    if (!has_label()) {
      alloc_label();
    }
    #endif
    #ifdef DEBUG
    if (!has_label()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return label_.get();
  }
  TmplValueDereference& label() {
    return *ptr_label();
  }
  const TmplValueDereference& label() const {
    #ifdef DEBUG
    if (!has_label()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *label_.get();
  }
  
  
  
  void set_items(std::vector<TmplItem>&& val) {
    items_ = std::move(val);
  }
  std::vector<TmplItem>& items() {
    return items_;
  }
  const std::vector<TmplItem>& items() const {
    return items_;
  }
  
  

 private:
  // label
  std::unique_ptr<TmplValueDereference> label_;
  // items
  std::vector<TmplItem> items_;
  
}; // class SwitchCase


// SwitchBlock struct declaration.
class SwitchBlock {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  SwitchBlock() {}
  ~SwitchBlock() {}

  SwitchBlock(const SwitchBlock&) = delete;
  SwitchBlock& operator=(const SwitchBlock&) = delete;
  SwitchBlock(SwitchBlock&&) = default;
  SwitchBlock& operator=(SwitchBlock&&) = default;

  

  
  
  bool has_identifier() const {
    return identifier_.operator bool();
  }
  void alloc_identifier() {
    identifier_ = std::make_unique<TmplValueDereference>();
  }
  void delete_identifier() {
    return identifier_.reset(nullptr);
  }
  void set_identifier(std::unique_ptr<TmplValueDereference> val) {
    identifier_ = std::move(val);
  }
  void set_identifier(TmplValueDereference* val) {
    identifier_.reset(std::move(val));
  }
  TmplValueDereference* ptr_identifier() {
    #if TD_AUTO_ALLOC
    if (!has_identifier()) {
      alloc_identifier();
    }
    #endif
    #ifdef DEBUG
    if (!has_identifier()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return identifier_.get();
  }
  TmplValueDereference& identifier() {
    return *ptr_identifier();
  }
  const TmplValueDereference& identifier() const {
    #ifdef DEBUG
    if (!has_identifier()) {
      TD_THROW("Attempted null reference");
    }
    #endif
    return *identifier_.get();
  }
  
  
  
  void set_cases(std::vector<SwitchCase>&& val) {
    cases_ = std::move(val);
  }
  std::vector<SwitchCase>& cases() {
    return cases_;
  }
  const std::vector<SwitchCase>& cases() const {
    return cases_;
  }
  
  
  
  void set_default_subblock(std::vector<TmplItem>&& val) {
    default_subblock_ = std::move(val);
  }
  std::vector<TmplItem>& default_subblock() {
    return default_subblock_;
  }
  const std::vector<TmplItem>& default_subblock() const {
    return default_subblock_;
  }
  
  

 private:
  // identifier
  std::unique_ptr<TmplValueDereference> identifier_;
  // cases
  std::vector<SwitchCase> cases_;
  // default_subblock
  std::vector<TmplItem> default_subblock_;
  
}; // class SwitchBlock


// td::codegen::cpp::TmplItem variant declaration.
class TmplItem {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  TmplItem() {}
  ~TmplItem() {
    tag = Tag::__TAG__UNSET;
  }

  TmplItem(const TmplItem&) = delete;
  TmplItem& operator=(const TmplItem&) = delete;
  TmplItem(TmplItem&&) = default;
  TmplItem& operator=(TmplItem&&) = default;

  

  enum class Tag {
    __TAG__UNSET = 0,
    TAG_text = 1,
    TAG_expression = 2,
    TAG_if_block = 3,
    TAG_for_block = 4,
    TAG_switch_block = 5,
    
  };
  Tag Which() const { return tag; }

  
  bool is_text() const {
    return val_.index() == 1;
  }
  
  std::string& text() {
    if (!is_text()) {
      tag = Tag::TAG_text;
      val_.emplace<1>();
    }
    return std::get<1>(val_);
  }
  const std::string& text() const {
    return std::get<1>(val_);
  }
  void set_text(std::string&& val) {
    tag = Tag::TAG_text;
    val_.emplace<1>(std::move(val));
  }
  
  bool is_expression() const {
    return val_.index() == 2;
  }
  
  bool has_expression() const {
    return is_expression() && std::get<2>(val_).operator bool();
  }
  void alloc_expression() {
    tag = Tag::TAG_expression;
    val_.emplace<2>(std::make_unique<TmplExpression>());
  }
  void delete_expression() {
    return std::get<2>(val_).reset(nullptr);
  }
  void set_expression(std::unique_ptr<TmplExpression> val) {
    tag = Tag::TAG_expression;
    val_.emplace<2>(std::move(val));
  }
  void set_expression(TmplExpression* val) {
    tag = Tag::TAG_expression;
    std::get<2>(val_).reset(std::move(val));
  }
  TmplExpression* ptr_expression() {
    #if TD_AUTO_ALLOC
    if (!has_expression()) {
      alloc_expression();
    }
    #endif
    return std::get<2>(val_).get();
  }
  TmplExpression& expression() {
    return *ptr_expression();
  }
  const TmplExpression& expression() const {
    return *std::get<2>(val_).get();
  }
  
  bool is_if_block() const {
    return val_.index() == 3;
  }
  
  bool has_if_block() const {
    return is_if_block() && std::get<3>(val_).operator bool();
  }
  void alloc_if_block() {
    tag = Tag::TAG_if_block;
    val_.emplace<3>(std::make_unique<TmplIfBlock>());
  }
  void delete_if_block() {
    return std::get<3>(val_).reset(nullptr);
  }
  void set_if_block(std::unique_ptr<TmplIfBlock> val) {
    tag = Tag::TAG_if_block;
    val_.emplace<3>(std::move(val));
  }
  void set_if_block(TmplIfBlock* val) {
    tag = Tag::TAG_if_block;
    std::get<3>(val_).reset(std::move(val));
  }
  TmplIfBlock* ptr_if_block() {
    #if TD_AUTO_ALLOC
    if (!has_if_block()) {
      alloc_if_block();
    }
    #endif
    return std::get<3>(val_).get();
  }
  TmplIfBlock& if_block() {
    return *ptr_if_block();
  }
  const TmplIfBlock& if_block() const {
    return *std::get<3>(val_).get();
  }
  
  bool is_for_block() const {
    return val_.index() == 4;
  }
  
  bool has_for_block() const {
    return is_for_block() && std::get<4>(val_).operator bool();
  }
  void alloc_for_block() {
    tag = Tag::TAG_for_block;
    val_.emplace<4>(std::make_unique<TmplForBlock>());
  }
  void delete_for_block() {
    return std::get<4>(val_).reset(nullptr);
  }
  void set_for_block(std::unique_ptr<TmplForBlock> val) {
    tag = Tag::TAG_for_block;
    val_.emplace<4>(std::move(val));
  }
  void set_for_block(TmplForBlock* val) {
    tag = Tag::TAG_for_block;
    std::get<4>(val_).reset(std::move(val));
  }
  TmplForBlock* ptr_for_block() {
    #if TD_AUTO_ALLOC
    if (!has_for_block()) {
      alloc_for_block();
    }
    #endif
    return std::get<4>(val_).get();
  }
  TmplForBlock& for_block() {
    return *ptr_for_block();
  }
  const TmplForBlock& for_block() const {
    return *std::get<4>(val_).get();
  }
  
  bool is_switch_block() const {
    return val_.index() == 5;
  }
  
  bool has_switch_block() const {
    return is_switch_block() && std::get<5>(val_).operator bool();
  }
  void alloc_switch_block() {
    tag = Tag::TAG_switch_block;
    val_.emplace<5>(std::make_unique<SwitchBlock>());
  }
  void delete_switch_block() {
    return std::get<5>(val_).reset(nullptr);
  }
  void set_switch_block(std::unique_ptr<SwitchBlock> val) {
    tag = Tag::TAG_switch_block;
    val_.emplace<5>(std::move(val));
  }
  void set_switch_block(SwitchBlock* val) {
    tag = Tag::TAG_switch_block;
    std::get<5>(val_).reset(std::move(val));
  }
  SwitchBlock* ptr_switch_block() {
    #if TD_AUTO_ALLOC
    if (!has_switch_block()) {
      alloc_switch_block();
    }
    #endif
    return std::get<5>(val_).get();
  }
  SwitchBlock& switch_block() {
    return *ptr_switch_block();
  }
  const SwitchBlock& switch_block() const {
    return *std::get<5>(val_).get();
  }
  

 private:
  Tag tag = Tag::__TAG__UNSET;

  std::variant<
    std::monostate
  , std::string
  , std::unique_ptr<TmplExpression>
  , std::unique_ptr<TmplIfBlock>
  , std::unique_ptr<TmplForBlock>
  , std::unique_ptr<SwitchBlock>
  
  > val_;

};  // class TmplItem


// TmplFunction struct declaration.
class TmplFunction {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  TmplFunction() {}
  ~TmplFunction() {}

  TmplFunction(const TmplFunction&) = delete;
  TmplFunction& operator=(const TmplFunction&) = delete;
  TmplFunction(TmplFunction&&) = default;
  TmplFunction& operator=(TmplFunction&&) = default;

  

  
  
  void set_identifier(std::string&& val) {
    identifier_ = std::move(val);
  }
  std::string& identifier() {
    return identifier_;
  }
  const std::string& identifier() const {
    return identifier_;
  }
  
  
  
  void set_params(std::vector<AccessInfo>&& val) {
    params_ = std::move(val);
  }
  std::vector<AccessInfo>& params() {
    return params_;
  }
  const std::vector<AccessInfo>& params() const {
    return params_;
  }
  
  
  
  void set_items(std::vector<TmplItem>&& val) {
    items_ = std::move(val);
  }
  std::vector<TmplItem>& items() {
    return items_;
  }
  const std::vector<TmplItem>& items() const {
    return items_;
  }
  
  

 private:
  // identifier
  std::string identifier_ = "";
  // params
  std::vector<AccessInfo> params_;
  // items
  std::vector<TmplItem> items_;
  
}; // class TmplFunction


// Options struct declaration.
class Options {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  Options() {}
  ~Options() {}

  Options(const Options&) = delete;
  Options& operator=(const Options&) = delete;
  Options(Options&&) = default;
  Options& operator=(Options&&) = default;

  

  
  
  bool get_generate_json_writer() const {
    return generate_json_writer_;
  }
  void set_generate_json_writer(bool val) {
    generate_json_writer_ = val;
  }
  bool& generate_json_writer() {
    return generate_json_writer_;
  }
  const bool& generate_json_writer() const {
    return generate_json_writer_;
  }
  
  
  
  bool get_generate_json_parser() const {
    return generate_json_parser_;
  }
  void set_generate_json_parser(bool val) {
    generate_json_parser_ = val;
  }
  bool& generate_json_parser() {
    return generate_json_parser_;
  }
  const bool& generate_json_parser() const {
    return generate_json_parser_;
  }
  
  

 private:
  // generate_json_writer
  bool generate_json_writer_ = 0;
  // generate_json_parser
  bool generate_json_parser_ = 0;
  
}; // class Options


// CppData struct declaration.
class CppData {
 public:
  // Nested type declarations
  
  // Inline type declarations
  

  CppData() {}
  ~CppData() {}

  CppData(const CppData&) = delete;
  CppData& operator=(const CppData&) = delete;
  CppData(CppData&&) = default;
  CppData& operator=(CppData&&) = default;

  

  
  
  void set_header_guard(std::string&& val) {
    header_guard_ = std::move(val);
  }
  std::string& header_guard() {
    return header_guard_;
  }
  const std::string& header_guard() const {
    return header_guard_;
  }
  
  
  
  void set_header_filename(std::string&& val) {
    header_filename_ = std::move(val);
  }
  std::string& header_filename() {
    return header_filename_;
  }
  const std::string& header_filename() const {
    return header_filename_;
  }
  
  
  
  void set_namespaces(std::vector<std::string>&& val) {
    namespaces_ = std::move(val);
  }
  std::vector<std::string>& namespaces() {
    return namespaces_;
  }
  const std::vector<std::string>& namespaces() const {
    return namespaces_;
  }
  
  
  
  void set_user_type_decls(std::vector<UserTypeDeclaration>&& val) {
    user_type_decls_ = std::move(val);
  }
  std::vector<UserTypeDeclaration>& user_type_decls() {
    return user_type_decls_;
  }
  const std::vector<UserTypeDeclaration>& user_type_decls() const {
    return user_type_decls_;
  }
  
  
  
  void set_tmpl_funcs(std::vector<TmplFunction>&& val) {
    tmpl_funcs_ = std::move(val);
  }
  std::vector<TmplFunction>& tmpl_funcs() {
    return tmpl_funcs_;
  }
  const std::vector<TmplFunction>& tmpl_funcs() const {
    return tmpl_funcs_;
  }
  
  

 private:
  // header_guard
  std::string header_guard_ = "";
  // header_filename
  std::string header_filename_ = "";
  // namespaces
  std::vector<std::string> namespaces_;
  // user_type_decls
  std::vector<UserTypeDeclaration> user_type_decls_;
  // tmpl_funcs
  std::vector<TmplFunction> tmpl_funcs_;
  
}; // class CppData


// Struct and variant JSON declarations


























































































// Tmplate function declarations
void TmplStructDeclaration(std::ostream& os, const StructDecl& s, const Options& opt);
std::string TmplStructDeclaration(const StructDecl& s, const Options& opt);void StructField(std::ostream& os, const AccessInfo& field);
std::string StructField(const AccessInfo& field);void TmplStructDefinition(std::ostream& os, const StructDecl& s, const Options& opt);
std::string TmplStructDefinition(const StructDecl& s, const Options& opt);void TmplVariantDeclaration(std::ostream& os, const StructDecl& v, const Options& opt);
std::string TmplVariantDeclaration(const StructDecl& v, const Options& opt);void TmplVariantDefinition(std::ostream& os, const StructDecl& v, const Options& opt);
std::string TmplVariantDefinition(const StructDecl& v, const Options& opt);void CppHeader(std::ostream& os, const CppData& d, const Options& opt);
std::string CppHeader(const CppData& d, const Options& opt);void CppSrcJsonWriterHelpers(std::ostream& os);
std::string CppSrcJsonWriterHelpers();void CppSrcJsonParserHelpers(std::ostream& os);
std::string CppSrcJsonParserHelpers();void CppSrcHelpers(std::ostream& os);
std::string CppSrcHelpers();void CppSource(std::ostream& os, const CppData& d, const Options& opt);
std::string CppSource(const CppData& d, const Options& opt);void VecUserTypeDeclarationT(std::ostream& os, const std::vector<UserTypeDeclaration>& ut, const Options& opt);
std::string VecUserTypeDeclarationT(const std::vector<UserTypeDeclaration>& ut, const Options& opt);void CppType(std::ostream& os, const AccessInfo& a);
std::string CppType(const AccessInfo& a);void QualifiedName(std::ostream& os, const std::vector<std::string>& fqn);
std::string QualifiedName(const std::vector<std::string>& fqn);void QualifiedSnakeName(std::ostream& os, const std::vector<std::string>& fqn);
std::string QualifiedSnakeName(const std::vector<std::string>& fqn);void JsonPrintKey(std::ostream& os, const AccessInfo& field);
std::string JsonPrintKey(const AccessInfo& field);void JsonPrintArray(std::ostream& os, const AccessInfo& value_type);
std::string JsonPrintArray(const AccessInfo& value_type);void JsonPrintMap(std::ostream& os, const AccessInfo& key_type, const AccessInfo& val_type);
std::string JsonPrintMap(const AccessInfo& key_type, const AccessInfo& val_type);void JsonPrintValue(std::ostream& os, const AccessInfo& t);
std::string JsonPrintValue(const AccessInfo& t);void JsonStructDefinitions(std::ostream& os, const StructDecl& s, const Options& opt);
std::string JsonStructDefinitions(const StructDecl& s, const Options& opt);void JsonVariantDefinitions(std::ostream& os, const StructDecl& s, const Options& opt);
std::string JsonVariantDefinitions(const StructDecl& s, const Options& opt);void JsonSrcForwardDeclarations(std::ostream& os, const StructDecl& s, const Options& opt);
std::string JsonSrcForwardDeclarations(const StructDecl& s, const Options& opt);void JsonParseArrayLambda(std::ostream& os, const AccessInfo& from_type);
std::string JsonParseArrayLambda(const AccessInfo& from_type);void JsonParseMapLambda(std::ostream& os, const AccessInfo& key_type, const AccessInfo& val_type);
std::string JsonParseMapLambda(const AccessInfo& key_type, const AccessInfo& val_type);void JsonSrcDefinitions(std::ostream& os, const StructDecl& s, const Options& opt);
std::string JsonSrcDefinitions(const StructDecl& s, const Options& opt);void JsonDeclarations(std::ostream& os, const StructDecl& s, const Options& opt);
std::string JsonDeclarations(const StructDecl& s, const Options& opt);void TmplValueDereferenceT(std::ostream& os, const TmplValueDereference& v);
std::string TmplValueDereferenceT(const TmplValueDereference& v);void TmplValueDereferenceToString(std::ostream& os, const TmplValueDereference& v);
std::string TmplValueDereferenceToString(const TmplValueDereference& v);void TmplStringExpression(std::ostream& os, const TmplExpression& i);
std::string TmplStringExpression(const TmplExpression& i);void TmplOStreamExpression(std::ostream& os, const TmplExpression& i);
std::string TmplOStreamExpression(const TmplExpression& i);void TmplBoolExpression(std::ostream& os, const TmplExpression& i);
std::string TmplBoolExpression(const TmplExpression& i);void TmplIfT(std::ostream& os, const TmplIf& i);
std::string TmplIfT(const TmplIf& i);void TmplIfBlockT(std::ostream& os, const TmplIfBlock& i);
std::string TmplIfBlockT(const TmplIfBlock& i);void TmplForT(std::ostream& os, const TmplForBlock& f);
std::string TmplForT(const TmplForBlock& f);void TmplHasValRef(std::ostream& os, const TmplValueDereference& val);
std::string TmplHasValRef(const TmplValueDereference& val);void TmplSwitchT(std::ostream& os, const SwitchBlock& s);
std::string TmplSwitchT(const SwitchBlock& s);void TmplItemsT(std::ostream& os, const std::vector<TmplItem>& v);
std::string TmplItemsT(const std::vector<TmplItem>& v);void TmplItemT(std::ostream& os, const TmplItem& i);
std::string TmplItemT(const TmplItem& i);void OStreamParamsList(std::ostream& os, const std::vector<AccessInfo>& params);
std::string OStreamParamsList(const std::vector<AccessInfo>& params);void ParamsList(std::ostream& os, const std::vector<AccessInfo>& params);
std::string ParamsList(const std::vector<AccessInfo>& params);void TmplFuncDeclaration(std::ostream& os, const TmplFunction& t);
std::string TmplFuncDeclaration(const TmplFunction& t);void TmplFuncDefinition(std::ostream& os, const TmplFunction& t);
std::string TmplFuncDefinition(const TmplFunction& t);

} // namespace td
} // namespace codegen
} // namespace cpp


#endif  // TD_CODEGEN_CPP_TD_CPP_H__


#include "s11n.td.h"

// Generated by the Typedef compiler

#include <string>
#include <sstream>
#include <locale>
#include <codecvt>
#include <iomanip>
// JSON parser required headers
#include "rapidjson/document.h"
#include <charconv>
#include <iomanip>
#include <locale>
// JSON writer required headers
#include <charconv>
#include <iomanip>
#include <locale>


namespace {

std::string escape_char32_t_as_literal(char32_t c) {
  switch (c) {
    case U'\a':
      return R"(U'\a')";
    case U'\b':
      return R"(U'\b')";
    case U'\f':
      return R"(U'\f')";
    case U'\n':
      return R"(U'\n')";
    case U'\r':
      return R"(U'\r')";
    case U'\t':
      return R"(U'\t')";
    case U'\v':
      return R"(U'\v')";
    case U'\'':
      return R"(U'\'')";
    case U'\"':
      return R"(U'\"')";
    case U'\\':
      return R"(U'\\')";
    default:
      if (c < 32 || c >= 0x7F) {
        // For characters outside of the ASCII range
        std::ostringstream oss;
        oss << "U'\\U" << std::setw(8) << std::setfill('0') << std::hex
            << std::uppercase << static_cast<int>(c) << "'";
        return oss.str();
      } else {
        // For all other characters, return as is
        return "U'" + std::string(1, static_cast<char>(c)) + "'";
      }
  }
}

template <typename T>
inline bool IsEmpty(const std::vector<T>& v) {
  return v.size() == 0;
}


inline std::string escape_json(const std::string& s) {
  std::ostringstream o;
  for (auto c = s.cbegin(); c != s.cend(); c++) {
    switch (*c) {
      case '"': o << "\\\""; break;
      case '\\': o << "\\\\"; break;
      case '\b': o << "\\b"; break;
      case '\f': o << "\\f"; break;
      case '\n': o << "\\n"; break;
      case '\r': o << "\\r"; break;
      case '\t': o << "\\t"; break;
      default:
        if ('\x00' <= *c && *c <= '\x1f') {
          o << "\\u" << std::hex << std::setw(4) << std::setfill('0')
            << static_cast<int>(*c);
        } else {
          o << *c;
        }
    }
  }
  return o.str();
}

inline std::string char32ToJsonString(char32_t c) {
  std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> converter;
  std::string utf8 = converter.to_bytes(&c, &c + 1);
  return escape_json(utf8);
}

// This is a very inefficint way of doing this, but
// C++17 standard libs don't give us great options.
// TODO: Also it may not work in C++20?
std::u32string decode_utf8(const std::string& utf8_string) {
  struct destructible_codecvt : public std::codecvt<char32_t, char, std::mbstate_t> {
    using std::codecvt<char32_t, char, std::mbstate_t>::codecvt;
    ~destructible_codecvt() = default;
  };
  std::wstring_convert<destructible_codecvt, char32_t> utf32_converter;
  return utf32_converter.from_bytes(utf8_string);
}

inline char32_t GetCharValue(std::string_view str) {
  if (str.size() == 2 && str[0] == '\\') {
    switch (str[1]) {
      case 'n':
        return U'\n';
      case 'r':
        return U'\r';
      case 't':
        return U'\t';
      case '\\':
        return U'\\';
      case '0':
        return U'\0';
      case '\'':
        return U'\'';
      case '\"':
        return U'\"';
    }
  }
  if (str.size() == 4 && str[0] == '\\' && str[1] == 'x') {
    // TODO this seems rather inefficient, do something better?
    std::istringstream ss(std::string(str.substr(2)));
    int value;
    ss >> std::hex >> value;
    return static_cast<char32_t>(value);
  }

  if (str.size() >= 3 && str.size() <= 10 && str[0] == '\\' && str[1] == 'u' &&
      str[2] == '{' && str.back() == '}') {
    // TODO this seems rather inefficient, do something better?
    std::istringstream ss(std::string(str.substr(3, str.size() - 4)));
    int value;
    ss >> std::hex >> value;
    return static_cast<char32_t>(value);
  }

  if (str.size() > 0) {
    std::string inner_str(str);
    std::u32string str32 = decode_utf8(inner_str);
    if (str32.size() == 1) {
      return str32[0];
    }
  }
  throw std::runtime_error("JSON format error: expected 'char'.");
}


bool JsonParseBool(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsBool()) {
    return val.GetBool();
  } else {
    throw std::runtime_error("JSON format error: expected 'bool'.");
  }
}
char32_t JsonParseChar(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsString()) {
    std::string str(val.GetString(), val.GetStringLength());
    return GetCharValue(str);
  } else {
    throw std::runtime_error("JSON format error: expected 'string'.");
  }
}
std::string JsonParseStr(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsString()) {
    return val.GetString();
  } else {
    throw std::runtime_error("JSON format error: expected 'string'.");
  }
}
float JsonParseF32(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsDouble()) {
    return (float)val.GetDouble();
  } else {
    throw std::runtime_error("JSON format error: expected 'float'.");
  }
}
double JsonParseF64(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsDouble()) {
    return val.GetDouble();
  } else {
    throw std::runtime_error("JSON format error: expected 'double'.");
  }
}
std::uint8_t JsonParseU8(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsUint()) {
    unsigned int ui = val.GetUint();
    if (ui > std::numeric_limits<std::uint8_t>::max() ||
        ui < std::numeric_limits<std::uint8_t>::min()) {
      throw std::runtime_error("JSON format error: unsigned integer '" +
                               std::to_string(ui) +
                               "' exceeded 'u8' capacity.");
    }
    return (std::uint8_t)ui;
  } else {
    throw std::runtime_error("JSON format error: expected 'unsigned integer'.");
  }
}
std::uint16_t JsonParseU16(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsUint()) {
    unsigned int ui = val.GetUint();
    if (ui > std::numeric_limits<std::uint16_t>::max() ||
        ui < std::numeric_limits<std::uint16_t>::min()) {
      throw std::runtime_error("JSON format error: unsigned integer '" +
                               std::to_string(ui) +
                               "' exceeded 'u16' capacity.");
    }
    return (std::uint16_t)ui;
  } else {
    throw std::runtime_error("JSON format error: expected 'unsigned integer'.");
  }
}
std::uint32_t JsonParseU32(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsUint()) {
    return val.GetUint();
  } else {
    throw std::runtime_error("JSON format error: expected 'unsigned integer'.");
  }
}
std::uint64_t JsonParseU64(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsUint64()) {
    return val.GetUint64();
  } else {
    throw std::runtime_error("JSON format error: expected 'unsigned integer'.");
  }
}
std::int8_t JsonParseI8(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsInt()) {
    int ui = val.GetInt();
    if (ui > std::numeric_limits<std::int8_t>::max() ||
        ui < std::numeric_limits<std::int8_t>::min()) {
      throw std::runtime_error("JSON format error: integer '" +
                               std::to_string(ui) +
                               "' exceeded 'i8' capacity.");
    }
    return (std::int8_t)ui;
  } else {
    throw std::runtime_error("JSON format error: expected 'integer'.");
  }
}
std::int16_t JsonParseI16(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsInt()) {
    int ui = val.GetInt();
    if (ui > std::numeric_limits<std::int16_t>::max() ||
        ui < std::numeric_limits<std::int16_t>::min()) {
      throw std::runtime_error("JSON format error: integer '" +
                               std::to_string(ui) +
                               "' exceeded 'i16' capacity.");
    }
    return (std::int16_t)ui;
  } else {
    throw std::runtime_error("JSON format error: expected 'integer'.");
  }
}
std::int32_t JsonParseI32(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsInt()) {
    return val.GetInt();
  } else {
    throw std::runtime_error("JSON format error: expected 'integer'.");
  }
}
std::int64_t JsonParseI64(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsInt64()) {
    return val.GetInt64();
  } else {
    throw std::runtime_error("JSON format error: expected 'integer'.");
  }
}
template <typename T>
T GetIntFromString(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (!val.IsString()) {
    throw std::runtime_error("JSON format error: expected 'string'.");
  }
  std::string digits = val.GetString();
  std::string_view digits_view(digits);
  T value{};
  auto result = std::from_chars(digits_view.begin(), digits_view.end(), value);
  bool ended_early = result.ptr != digits_view.end();
  if (result.ec == std::errc() && !ended_early) {
    return value;
  } else if (result.ec == std::errc::invalid_argument) {
    throw std::runtime_error(
        "JSON format error: expected string encoded integer.");
  } else if (result.ec == std::errc::result_out_of_range) {
    throw std::runtime_error("JSON format error: number out of range.");
  } else {
    throw std::runtime_error(
        "JSON format error: expected string encoded integer.");
  }
}
bool GetBoolFromString(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (!val.IsString()) {
    throw std::runtime_error("JSON format error: expected 'string'.");
  }
  std::string maybe_bool_str = val.GetString();
  if (maybe_bool_str == "true") {
    return true;
  } else if (maybe_bool_str == "false") {
    return false;
  } else {
    throw std::runtime_error(
        "JSON format error: expected string encoded bool 'true' or 'false'.");
  }
}

// Struct and variant JSON forward declarations

// Struct and variant JSON definitions

}

namespace s11n {

// Struct and variant definitions

// Struct and variant JSON declarations

// Tmplate function definitions


} // namespace s11n



#include "simple_values.td.h"

// Generated by the Typedef compiler (EXPERIMENTAL)

#include <string>
#include <sstream>
#include <locale>
#include <codecvt>
#include <iomanip>
// JSON parser required headers
#include "rapidjson/document.h"
#include <charconv>
#include <iomanip>
#include <locale>
// JSON writer required headers
#include <charconv>
#include <iomanip>
#include <locale>


namespace {

std::string escape_char32_t_as_literal(char32_t c) {
  switch (c) {
    case U'\a':
      return R"(U'\a')";
    case U'\b':
      return R"(U'\b')";
    case U'\f':
      return R"(U'\f')";
    case U'\n':
      return R"(U'\n')";
    case U'\r':
      return R"(U'\r')";
    case U'\t':
      return R"(U'\t')";
    case U'\v':
      return R"(U'\v')";
    case U'\'':
      return R"(U'\'')";
    case U'\"':
      return R"(U'\"')";
    case U'\\':
      return R"(U'\\')";
    default:
      if (c < 32 || c >= 0x7F) {
        // For characters outside of the ASCII range
        std::ostringstream oss;
        oss << "U'\\U" << std::setw(8) << std::setfill('0') << std::hex
            << std::uppercase << static_cast<int>(c) << "'";
        return oss.str();
      } else {
        // For all other characters, return as is
        return "U'" + std::string(1, static_cast<char>(c)) + "'";
      }
  }
}

template <typename T>
inline bool IsEmpty(const std::vector<T>& v) {
  return v.size() == 0;
}


inline std::string escape_json(const std::string& s) {
  std::ostringstream o;
  for (auto c = s.cbegin(); c != s.cend(); c++) {
    switch (*c) {
      case '"': o << "\\\""; break;
      case '\\': o << "\\\\"; break;
      case '\b': o << "\\b"; break;
      case '\f': o << "\\f"; break;
      case '\n': o << "\\n"; break;
      case '\r': o << "\\r"; break;
      case '\t': o << "\\t"; break;
      default:
        if ('\x00' <= *c && *c <= '\x1f') {
          o << "\\u" << std::hex << std::setw(4) << std::setfill('0')
            << static_cast<int>(*c);
        } else {
          o << *c;
        }
    }
  }
  return o.str();
}

inline std::string char32ToJsonString(char32_t c) {
  std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> converter;
  std::string utf8 = converter.to_bytes(&c, &c + 1);
  return escape_json(utf8);
}

// This is a very inefficint way of doing this, but
// C++17 standard libs don't give us great options.
// TODO: Also it may not work in C++20?
std::u32string decode_utf8(const std::string& utf8_string) {
  struct destructible_codecvt : public std::codecvt<char32_t, char, std::mbstate_t> {
    using std::codecvt<char32_t, char, std::mbstate_t>::codecvt;
    ~destructible_codecvt() = default;
  };
  std::wstring_convert<destructible_codecvt, char32_t> utf32_converter;
  return utf32_converter.from_bytes(utf8_string);
}

inline char32_t GetCharValue(std::string_view str) {
  if (str.size() == 2 && str[0] == '\\') {
    switch (str[1]) {
      case 'n':
        return U'\n';
      case 'r':
        return U'\r';
      case 't':
        return U'\t';
      case '\\':
        return U'\\';
      case '0':
        return U'\0';
      case '\'':
        return U'\'';
      case '\"':
        return U'\"';
    }
  }
  if (str.size() == 4 && str[0] == '\\' && str[1] == 'x') {
    // TODO this seems rather inefficient, do something better?
    std::istringstream ss(std::string(str.substr(2)));
    int value;
    ss >> std::hex >> value;
    return static_cast<char32_t>(value);
  }

  if (str.size() >= 3 && str.size() <= 10 && str[0] == '\\' && str[1] == 'u' &&
      str[2] == '{' && str.back() == '}') {
    // TODO this seems rather inefficient, do something better?
    std::istringstream ss(std::string(str.substr(3, str.size() - 4)));
    int value;
    ss >> std::hex >> value;
    return static_cast<char32_t>(value);
  }

  if (str.size() > 0) {
    std::string inner_str(str);
    std::u32string str32 = decode_utf8(inner_str);
    if (str32.size() == 1) {
      return str32[0];
    }
  }
  throw std::runtime_error("JSON format error: expected 'char'.");
}


bool JsonParseBool(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsBool()) {
    return val.GetBool();
  } else {
    throw std::runtime_error("JSON format error: expected 'bool'.");
  }
}
char32_t JsonParseChar(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsString()) {
    std::string str(val.GetString(), val.GetStringLength());
    return GetCharValue(str);
  } else {
    throw std::runtime_error("JSON format error: expected 'string'.");
  }
}
std::string JsonParseStr(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsString()) {
    return val.GetString();
  } else {
    throw std::runtime_error("JSON format error: expected 'string'.");
  }
}
float JsonParseF32(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsDouble()) {
    return (float)val.GetDouble();
  } else {
    throw std::runtime_error("JSON format error: expected 'float'.");
  }
}
double JsonParseF64(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsDouble()) {
    return val.GetDouble();
  } else {
    throw std::runtime_error("JSON format error: expected 'double'.");
  }
}
std::uint8_t JsonParseU8(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsUint()) {
    unsigned int ui = val.GetUint();
    if (ui > std::numeric_limits<std::uint8_t>::max() ||
        ui < std::numeric_limits<std::uint8_t>::min()) {
      throw std::runtime_error("JSON format error: unsigned integer '" +
                               std::to_string(ui) +
                               "' exceeded 'u8' capacity.");
    }
    return (std::uint8_t)ui;
  } else {
    throw std::runtime_error("JSON format error: expected 'unsigned integer'.");
  }
}
std::uint16_t JsonParseU16(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsUint()) {
    unsigned int ui = val.GetUint();
    if (ui > std::numeric_limits<std::uint16_t>::max() ||
        ui < std::numeric_limits<std::uint16_t>::min()) {
      throw std::runtime_error("JSON format error: unsigned integer '" +
                               std::to_string(ui) +
                               "' exceeded 'u16' capacity.");
    }
    return (std::uint16_t)ui;
  } else {
    throw std::runtime_error("JSON format error: expected 'unsigned integer'.");
  }
}
std::uint32_t JsonParseU32(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsUint()) {
    return val.GetUint();
  } else {
    throw std::runtime_error("JSON format error: expected 'unsigned integer'.");
  }
}
std::uint64_t JsonParseU64(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsUint64()) {
    return val.GetUint64();
  } else {
    throw std::runtime_error("JSON format error: expected 'unsigned integer'.");
  }
}
std::int8_t JsonParseI8(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsInt()) {
    int ui = val.GetInt();
    if (ui > std::numeric_limits<std::int8_t>::max() ||
        ui < std::numeric_limits<std::int8_t>::min()) {
      throw std::runtime_error("JSON format error: integer '" +
                               std::to_string(ui) +
                               "' exceeded 'i8' capacity.");
    }
    return (std::int8_t)ui;
  } else {
    throw std::runtime_error("JSON format error: expected 'integer'.");
  }
}
std::int16_t JsonParseI16(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsInt()) {
    int ui = val.GetInt();
    if (ui > std::numeric_limits<std::int16_t>::max() ||
        ui < std::numeric_limits<std::int16_t>::min()) {
      throw std::runtime_error("JSON format error: integer '" +
                               std::to_string(ui) +
                               "' exceeded 'i16' capacity.");
    }
    return (std::int16_t)ui;
  } else {
    throw std::runtime_error("JSON format error: expected 'integer'.");
  }
}
std::int32_t JsonParseI32(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsInt()) {
    return val.GetInt();
  } else {
    throw std::runtime_error("JSON format error: expected 'integer'.");
  }
}
std::int64_t JsonParseI64(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (val.IsInt64()) {
    return val.GetInt64();
  } else {
    throw std::runtime_error("JSON format error: expected 'integer'.");
  }
}
template <typename T>
T GetIntFromString(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (!val.IsString()) {
    throw std::runtime_error("JSON format error: expected 'string'.");
  }
  std::string digits = val.GetString();
  std::string_view digits_view(digits);
  T value{};
  auto result = std::from_chars(digits_view.begin(), digits_view.end(), value);
  bool ended_early = result.ptr != digits_view.end();
  if (result.ec == std::errc() && !ended_early) {
    return value;
  } else if (result.ec == std::errc::invalid_argument) {
    throw std::runtime_error(
        "JSON format error: expected string encoded integer.");
  } else if (result.ec == std::errc::result_out_of_range) {
    throw std::runtime_error("JSON format error: number out of range.");
  } else {
    throw std::runtime_error(
        "JSON format error: expected string encoded integer.");
  }
}
bool GetBoolFromString(const rapidjson::GenericValue<rapidjson::UTF8<>>& val) {
  if (!val.IsString()) {
    throw std::runtime_error("JSON format error: expected 'string'.");
  }
  std::string maybe_bool_str = val.GetString();
  if (maybe_bool_str == "true") {
    return true;
  } else if (maybe_bool_str == "false") {
    return false;
  } else {
    throw std::runtime_error(
        "JSON format error: expected string encoded bool 'true' or 'false'.");
  }
}

// Struct and variant JSON forward declarations

simple_values::StructA JsonParseStructA(const rapidjson::Value& obj);

simple_values::StructB JsonParseStructB(const rapidjson::Value& obj);

simple_values::StructC JsonParseStructC(const rapidjson::Value& obj);

simple_values::VariantA JsonParseVariantA(const rapidjson::Value& obj);

simple_values::VariantB JsonParseVariantB(const rapidjson::Value& obj);

simple_values::StructD JsonParseStructD(const rapidjson::Value& obj);

simple_values::StructE JsonParseStructE(const rapidjson::Value& obj);

simple_values::StructE::VariantE JsonParseStructE_VariantE(const rapidjson::Value& obj);

simple_values::StructE::NestedStruct JsonParseStructE_NestedStruct(const rapidjson::Value& obj);

simple_values::StructE::NestedVariant JsonParseStructE_NestedVariant(const rapidjson::Value& obj);

simple_values::StructE::inlineStructT JsonParseStructE_inlineStructT(const rapidjson::Value& obj);

simple_values::VariantC JsonParseVariantC(const rapidjson::Value& obj);

simple_values::VariantC::NestedStruct JsonParseVariantC_NestedStruct(const rapidjson::Value& obj);

simple_values::VariantC::NestedVariant JsonParseVariantC_NestedVariant(const rapidjson::Value& obj);

simple_values::VariantC::inlineStructT JsonParseVariantC_inlineStructT(const rapidjson::Value& obj);

simple_values::VariantC::VariantFT JsonParseVariantC_VariantFT(const rapidjson::Value& obj);

// Struct and variant JSON definitions

simple_values::StructA JsonParseStructA(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::StructA ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_bool");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_bool() = JsonParseBool(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_char");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_char() = JsonParseChar(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_str");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_str() = JsonParseStr(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_f32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_f32() = JsonParseF32(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_f64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_f64() = JsonParseF64(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u8");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_u8() = JsonParseU8(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u16");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_u16() = JsonParseU16(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_u32() = JsonParseU32(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_u64() = JsonParseU64(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i8");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_i8() = JsonParseI8(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i16");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_i16() = JsonParseI16(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_i32() = JsonParseI32(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_i64() = JsonParseI64(val);
  }
  } 
  return ret;
}


simple_values::StructB JsonParseStructB(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::StructB ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_bool");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_bool() = JsonParseBool(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_char");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_char() = JsonParseChar(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_str");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_str() = JsonParseStr(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_f32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_f32() = JsonParseF32(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_f64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_f64() = JsonParseF64(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u8");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_u8() = JsonParseU8(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u16");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_u16() = JsonParseU16(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_u32() = JsonParseU32(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_u64() = JsonParseU64(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i8");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_i8() = JsonParseI8(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i16");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_i16() = JsonParseI16(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_i32() = JsonParseI32(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.example_i64() = JsonParseI64(val);
  }
  } 
  return ret;
}


simple_values::StructC JsonParseStructC(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::StructC ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("asdf");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      ret.asdf() = JsonParseStructA(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("zxcv");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.zxcv() = JsonParseI32(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("jkl");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.jkl() = JsonParseI32(val);
  }
  } 
  return ret;
}


simple_values::VariantA JsonParseVariantA(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::VariantA ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.a() = JsonParseBool(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("b");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.b() = JsonParseI8(val);
  }
  } 
  return ret;
}


simple_values::VariantB JsonParseVariantB(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::VariantB ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.a() = JsonParseBool(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("b");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.b() = JsonParseChar(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("c");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.c() = JsonParseStr(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("d");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.d() = JsonParseU8(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("e");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.e() = JsonParseU16(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("f");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.f() = JsonParseU32(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("g");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.g() = JsonParseU64(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("h");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.h() = JsonParseI8(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("i");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.i() = JsonParseI16(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("j");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.j() = JsonParseI32(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("k");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.k() = JsonParseI64(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("sa");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      ret.sa() = JsonParseStructA(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("sb");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      ret.sb() = JsonParseStructB(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("sc");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      ret.sc() = JsonParseStructC(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("va");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsArray()) {
      
auto json_parse_array_lambda = [](auto& value_type, const rapidjson::Value& src) {
  using VectorType = std::remove_reference_t<decltype(value_type)>;
  VectorType vec;
  for (rapidjson::SizeType ii = 0; ii < src.Size(); ii++) {
    vec.push_back(JsonParseU8(src[ii]));
  }
  return vec;
};

      ret.va() = json_parse_array_lambda(ret.va(), val);
    } else {
      throw std::runtime_error("JSON format error: expected 'array'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("vara");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      if (val.MemberCount() > 1) {
        throw std::runtime_error("JSON format error: one member expected for variant type; found " + std::to_string(val.MemberCount()));
      }
      ret.vara() = JsonParseVariantA(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("mapa");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      
auto json_parse_map_lambda = [](auto& value_type, const rapidjson::Value& src) {
  using MapType = std::remove_reference_t<decltype(value_type)>;
  MapType map;
  using KeyType = typename MapType::key_type;
  using ValType = typename MapType::mapped_type;
  using PairType = std::pair<const KeyType, ValType>;
  for (auto& m : src.GetObject()) {
    KeyType key = GetIntFromString<std::int32_t>(m.name);

    
    ValType map_val;
    if (m.value.IsObject()) {
      if (m.value.MemberCount() > 1) {
        throw std::runtime_error("JSON format error: one member expected for variant type; found " + std::to_string(m.value.MemberCount()));
      }
      map_val = JsonParseVariantB(m.value);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }

    map.emplace(std::make_pair(key, std::move(map_val)));
  }
  return map;
};

      ret.mapa() = json_parse_map_lambda(ret.mapa(), val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
    
  }
  } 
  return ret;
}


simple_values::StructD JsonParseStructD(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::StructD ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a_struct");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      ret.a_struct() = JsonParseStructA(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("b_variant");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      if (val.MemberCount() > 1) {
        throw std::runtime_error("JSON format error: one member expected for variant type; found " + std::to_string(val.MemberCount()));
      }
      ret.b_variant() = JsonParseVariantA(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("c_vec");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsArray()) {
      
auto json_parse_array_lambda = [](auto& value_type, const rapidjson::Value& src) {
  using VectorType = std::remove_reference_t<decltype(value_type)>;
  VectorType vec;
  for (rapidjson::SizeType ii = 0; ii < src.Size(); ii++) {
    vec.push_back(JsonParseU8(src[ii]));
  }
  return vec;
};

      ret.c_vec() = json_parse_array_lambda(ret.c_vec(), val);
    } else {
      throw std::runtime_error("JSON format error: expected 'array'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("d_map");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      
auto json_parse_map_lambda = [](auto& value_type, const rapidjson::Value& src) {
  using MapType = std::remove_reference_t<decltype(value_type)>;
  MapType map;
  using KeyType = typename MapType::key_type;
  using ValType = typename MapType::mapped_type;
  using PairType = std::pair<const KeyType, ValType>;
  for (auto& m : src.GetObject()) {
    KeyType key = GetIntFromString<std::int32_t>(m.name);

    
    ValType map_val;
    if (m.value.IsObject()) {
      if (m.value.MemberCount() > 1) {
        throw std::runtime_error("JSON format error: one member expected for variant type; found " + std::to_string(m.value.MemberCount()));
      }
      map_val = JsonParseVariantB(m.value);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }

    map.emplace(std::make_pair(key, std::move(map_val)));
  }
  return map;
};

      ret.d_map() = json_parse_map_lambda(ret.d_map(), val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
    
  }
  } 
  return ret;
}


simple_values::StructE JsonParseStructE(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::StructE ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("inlineStruct");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      ret.inlineStruct() = JsonParseStructE_inlineStructT(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("vec_a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsArray()) {
      
auto json_parse_array_lambda = [](auto& value_type, const rapidjson::Value& src) {
  using VectorType = std::remove_reference_t<decltype(value_type)>;
  VectorType vec;
  for (rapidjson::SizeType ii = 0; ii < src.Size(); ii++) {
    vec.push_back(JsonParseI32(src[ii]));
  }
  return vec;
};

      ret.vec_a() = json_parse_array_lambda(ret.vec_a(), val);
    } else {
      throw std::runtime_error("JSON format error: expected 'array'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("map_a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      
auto json_parse_map_lambda = [](auto& value_type, const rapidjson::Value& src) {
  using MapType = std::remove_reference_t<decltype(value_type)>;
  MapType map;
  using KeyType = typename MapType::key_type;
  using ValType = typename MapType::mapped_type;
  using PairType = std::pair<const KeyType, ValType>;
  for (auto& m : src.GetObject()) {
    KeyType key = JsonParseStr(m.name);

    
    ValType map_val;
    if (m.value.IsObject()) {
      map_val = JsonParseStructD(m.value);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }

    map.emplace(std::make_pair(key, std::move(map_val)));
  }
  return map;
};

      ret.map_a() = json_parse_map_lambda(ret.map_a(), val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
    
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("nestedStructField");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      ret.nestedStructField() = JsonParseStructE_NestedStruct(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("nestedVariantField");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      if (val.MemberCount() > 1) {
        throw std::runtime_error("JSON format error: one member expected for variant type; found " + std::to_string(val.MemberCount()));
      }
      ret.nestedVariantField() = JsonParseStructE_NestedVariant(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } 
  return ret;
}

simple_values::StructE::VariantE JsonParseStructE_VariantE(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::StructE::VariantE ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("va");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.va() = JsonParseI32(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("vb");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.vb() = JsonParseStr(val);
  }
  } 
  return ret;
}


simple_values::StructE::NestedStruct JsonParseStructE_NestedStruct(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::StructE::NestedStruct ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.a() = JsonParseI32(val);
  }
  } 
  return ret;
}


simple_values::StructE::NestedVariant JsonParseStructE_NestedVariant(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::StructE::NestedVariant ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.a() = JsonParseI64(val);
  }
  } 
  return ret;
}


simple_values::StructE::inlineStructT JsonParseStructE_inlineStructT(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::StructE::inlineStructT ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.a() = JsonParseI32(val);
  }
  } 
  return ret;
}



simple_values::VariantC JsonParseVariantC(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::VariantC ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("inlineStruct");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      ret.inlineStruct() = JsonParseVariantC_inlineStructT(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("VariantF");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      if (val.MemberCount() > 1) {
        throw std::runtime_error("JSON format error: one member expected for variant type; found " + std::to_string(val.MemberCount()));
      }
      ret.VariantF() = JsonParseVariantC_VariantFT(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("vec_a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsArray()) {
      
auto json_parse_array_lambda = [](auto& value_type, const rapidjson::Value& src) {
  using VectorType = std::remove_reference_t<decltype(value_type)>;
  VectorType vec;
  for (rapidjson::SizeType ii = 0; ii < src.Size(); ii++) {
    vec.push_back(JsonParseI32(src[ii]));
  }
  return vec;
};

      ret.vec_a() = json_parse_array_lambda(ret.vec_a(), val);
    } else {
      throw std::runtime_error("JSON format error: expected 'array'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("map_a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      
auto json_parse_map_lambda = [](auto& value_type, const rapidjson::Value& src) {
  using MapType = std::remove_reference_t<decltype(value_type)>;
  MapType map;
  using KeyType = typename MapType::key_type;
  using ValType = typename MapType::mapped_type;
  using PairType = std::pair<const KeyType, ValType>;
  for (auto& m : src.GetObject()) {
    KeyType key = JsonParseStr(m.name);

    
    ValType map_val;
    if (m.value.IsObject()) {
      map_val = JsonParseStructD(m.value);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }

    map.emplace(std::make_pair(key, std::move(map_val)));
  }
  return map;
};

      ret.map_a() = json_parse_map_lambda(ret.map_a(), val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
    
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("nestedStructField");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      ret.nestedStructField() = JsonParseVariantC_NestedStruct(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("nestedVariantField");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      if (val.MemberCount() > 1) {
        throw std::runtime_error("JSON format error: one member expected for variant type; found " + std::to_string(val.MemberCount()));
      }
      ret.nestedVariantField() = JsonParseVariantC_NestedVariant(val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("map_b");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsObject()) {
      
auto json_parse_map_lambda = [](auto& value_type, const rapidjson::Value& src) {
  using MapType = std::remove_reference_t<decltype(value_type)>;
  MapType map;
  using KeyType = typename MapType::key_type;
  using ValType = typename MapType::mapped_type;
  using PairType = std::pair<const KeyType, ValType>;
  for (auto& m : src.GetObject()) {
    KeyType key = GetIntFromString<std::int32_t>(m.name);

    
    ValType map_val;
    if (m.value.IsObject()) {
      if (m.value.MemberCount() > 1) {
        throw std::runtime_error("JSON format error: one member expected for variant type; found " + std::to_string(m.value.MemberCount()));
      }
      map_val = JsonParseVariantC_NestedVariant(m.value);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }

    map.emplace(std::make_pair(key, std::move(map_val)));
  }
  return map;
};

      ret.map_b() = json_parse_map_lambda(ret.map_b(), val);
    } else {
      throw std::runtime_error("JSON format error: expected 'object'.");
    }
    
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("vec_b");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
    if (val.IsArray()) {
      
auto json_parse_array_lambda = [](auto& value_type, const rapidjson::Value& src) {
  using VectorType = std::remove_reference_t<decltype(value_type)>;
  VectorType vec;
  for (rapidjson::SizeType ii = 0; ii < src.Size(); ii++) {
    vec.push_back(JsonParseI32(src[ii]));
  }
  return vec;
};

      ret.vec_b() = json_parse_array_lambda(ret.vec_b(), val);
    } else {
      throw std::runtime_error("JSON format error: expected 'array'.");
    }
  }
  } 
  return ret;
}

simple_values::VariantC::NestedStruct JsonParseVariantC_NestedStruct(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::VariantC::NestedStruct ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.a() = JsonParseI32(val);
  }
  } 
  return ret;
}


simple_values::VariantC::NestedVariant JsonParseVariantC_NestedVariant(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::VariantC::NestedVariant ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.a() = JsonParseI64(val);
  }
  } 
  return ret;
}


simple_values::VariantC::inlineStructT JsonParseVariantC_inlineStructT(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::VariantC::inlineStructT ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.a() = JsonParseI32(val);
  }
  } 
  return ret;
}


simple_values::VariantC::VariantFT JsonParseVariantC_VariantFT(const rapidjson::Value& val) {
  if (!val.IsObject()) {
    throw std::runtime_error("JSON format error: expected 'object'.");
  }
  simple_values::VariantC::VariantFT ret;
  {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("va");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.va() = JsonParseI32(val);
  }
  } {
  auto obj = val.GetObject();
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("vb");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    ret.vb() = JsonParseStr(val);
  }
  } 
  return ret;
}



}

namespace simple_values {

// Struct and variant definitions

// StructA member definitions

// StructB member definitions

// StructC member definitions

// simple_values::VariantA member definitions

// simple_values::VariantB member definitions

// StructD member definitions

// StructE member definitions

// simple_values::VariantC member definitions

// Struct and variant JSON declarations

std::string ToJson(const StructA& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructA& from) {
  os << "{";
  
os << "\"example_bool\":"; os << (from.example_bool() ? "true" : "false");
os << ",";
os << "\"example_char\":"; os << "\"" << char32ToJsonString(from.example_char()) << "\"";
os << ",";
os << "\"example_str\":"; os << "\"" << escape_json(from.example_str()) << "\"";
os << ",";
os << "\"example_f32\":"; os << from.example_f32();
os << ",";
os << "\"example_f64\":"; os << from.example_f64();
os << ",";
os << "\"example_u8\":"; os << (int)from.example_u8();
os << ",";
os << "\"example_u16\":"; os << from.example_u16();
os << ",";
os << "\"example_u32\":"; os << from.example_u32();
os << ",";
os << "\"example_u64\":"; os << from.example_u64();
os << ",";
os << "\"example_i8\":"; os << (int)from.example_i8();
os << ",";
os << "\"example_i16\":"; os << from.example_i16();
os << ",";
os << "\"example_i32\":"; os << from.example_i32();
os << ",";
os << "\"example_i64\":"; os << from.example_i64();

  os << "}";
}

StructA StructA::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructA(doc);
}


std::string ToJson(const StructB& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructB& from) {
  os << "{";
  
os << "\"example_bool\":"; os << (from.example_bool() ? "true" : "false");
os << ",";
os << "\"example_char\":"; os << "\"" << char32ToJsonString(from.example_char()) << "\"";
os << ",";
os << "\"example_str\":"; os << "\"" << escape_json(from.example_str()) << "\"";
os << ",";
os << "\"example_f32\":"; os << from.example_f32();
os << ",";
os << "\"example_f64\":"; os << from.example_f64();
os << ",";
os << "\"example_u8\":"; os << (int)from.example_u8();
os << ",";
os << "\"example_u16\":"; os << from.example_u16();
os << ",";
os << "\"example_u32\":"; os << from.example_u32();
os << ",";
os << "\"example_u64\":"; os << from.example_u64();
os << ",";
os << "\"example_i8\":"; os << (int)from.example_i8();
os << ",";
os << "\"example_i16\":"; os << from.example_i16();
os << ",";
os << "\"example_i32\":"; os << from.example_i32();
os << ",";
os << "\"example_i64\":"; os << from.example_i64();

  os << "}";
}

StructB StructB::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructB(doc);
}


std::string ToJson(const StructC& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructC& from) {
  os << "{";
  
if (from.has_asdf()) {os << "\"asdf\":"; ToJson(os, from.asdf());} else {os << "\"asdf\":"; os << "null";}
os << ",";
os << "\"zxcv\":"; os << from.zxcv();
os << ",";
os << "\"jkl\":"; os << from.jkl();

  os << "}";
}

StructC StructC::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructC(doc);
}


std::string ToJson(const VariantA& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const VariantA& from) {
  os << "{";
  
  if (from.is_a()) {
    
os << "\"a\":"; os << (from.a() ? "true" : "false");

  }
  
  if (from.is_b()) {
    
os << "\"b\":"; os << (int)from.b();

  }
  
  os << "}";
}


VariantA VariantA::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseVariantA(doc);
}


std::string ToJson(const VariantB& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const VariantB& from) {
  os << "{";
  
  if (from.is_a()) {
    
os << "\"a\":"; os << (from.a() ? "true" : "false");

  }
  
  if (from.is_b()) {
    
os << "\"b\":"; os << "\"" << char32ToJsonString(from.b()) << "\"";

  }
  
  if (from.is_c()) {
    
os << "\"c\":"; os << "\"" << escape_json(from.c()) << "\"";

  }
  
  if (from.is_d()) {
    
os << "\"d\":"; os << (int)from.d();

  }
  
  if (from.is_e()) {
    
os << "\"e\":"; os << from.e();

  }
  
  if (from.is_f()) {
    
os << "\"f\":"; os << from.f();

  }
  
  if (from.is_g()) {
    
os << "\"g\":"; os << from.g();

  }
  
  if (from.is_h()) {
    
os << "\"h\":"; os << (int)from.h();

  }
  
  if (from.is_i()) {
    
os << "\"i\":"; os << from.i();

  }
  
  if (from.is_j()) {
    
os << "\"j\":"; os << from.j();

  }
  
  if (from.is_k()) {
    
os << "\"k\":"; os << from.k();

  }
  
  if (from.is_sa()) {
    
if (from.has_sa()) {os << "\"sa\":"; ToJson(os, from.sa());} else {os << "\"sa\":"; os << "null";}

  }
  
  if (from.is_sb()) {
    
if (from.has_sb()) {os << "\"sb\":"; ToJson(os, from.sb());} else {os << "\"sb\":"; os << "null";}

  }
  
  if (from.is_sc()) {
    
if (from.has_sc()) {os << "\"sc\":"; ToJson(os, from.sc());} else {os << "\"sc\":"; os << "null";}

  }
  
  if (from.is_va()) {
    
os << "\"va\":";
{
  auto& arr = from.va();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << (int)val;
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}

  }
  
  if (from.is_vara()) {
    
if (from.has_vara()) {os << "\"vara\":"; ToJson(os, from.vara());} else {os << "\"vara\":"; os << "null";}

  }
  
  if (from.is_mapa()) {
    
os << "\"mapa\":";
{
  auto& map = from.mapa();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << std::to_string(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  ToJson(os, val);
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}

  }
  
  os << "}";
}


VariantB VariantB::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseVariantB(doc);
}


std::string ToJson(const StructD& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructD& from) {
  os << "{";
  
if (from.has_a_struct()) {os << "\"a_struct\":"; ToJson(os, from.a_struct());} else {os << "\"a_struct\":"; os << "null";}
os << ",";
if (from.has_b_variant()) {os << "\"b_variant\":"; ToJson(os, from.b_variant());} else {os << "\"b_variant\":"; os << "null";}
os << ",";
os << "\"c_vec\":";
{
  auto& arr = from.c_vec();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << (int)val;
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}
os << ",";
os << "\"d_map\":";
{
  auto& map = from.d_map();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << std::to_string(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  ToJson(os, val);
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}

  os << "}";
}

StructD StructD::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructD(doc);
}


std::string ToJson(const StructE& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructE& from) {
  os << "{";
  
if (from.has_inlineStruct()) {os << "\"inlineStruct\":"; ToJson(os, from.inlineStruct());} else {os << "\"inlineStruct\":"; os << "null";}
os << ",";
os << "\"vec_a\":";
{
  auto& arr = from.vec_a();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << val;
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}
os << ",";
os << "\"map_a\":";
{
  auto& map = from.map_a();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << escape_json(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  ToJson(os, val);
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}
os << ",";
if (from.has_nestedStructField()) {os << "\"nestedStructField\":"; ToJson(os, from.nestedStructField());} else {os << "\"nestedStructField\":"; os << "null";}
os << ",";
if (from.has_nestedVariantField()) {os << "\"nestedVariantField\":"; ToJson(os, from.nestedVariantField());} else {os << "\"nestedVariantField\":"; os << "null";}

  os << "}";
}

StructE StructE::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructE(doc);
}

std::string ToJson(const StructE::VariantE& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructE::VariantE& from) {
  os << "{";
  
  if (from.is_va()) {
    
os << "\"va\":"; os << from.va();

  }
  
  if (from.is_vb()) {
    
os << "\"vb\":"; os << "\"" << escape_json(from.vb()) << "\"";

  }
  
  os << "}";
}


StructE::VariantE StructE::VariantE::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructE_VariantE(doc);
}


std::string ToJson(const StructE::NestedStruct& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructE::NestedStruct& from) {
  os << "{";
  
os << "\"a\":"; os << from.a();

  os << "}";
}

StructE::NestedStruct StructE::NestedStruct::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructE_NestedStruct(doc);
}


std::string ToJson(const StructE::NestedVariant& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructE::NestedVariant& from) {
  os << "{";
  
  if (from.is_a()) {
    
os << "\"a\":"; os << from.a();

  }
  
  os << "}";
}


StructE::NestedVariant StructE::NestedVariant::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructE_NestedVariant(doc);
}



std::string ToJson(const StructE::inlineStructT& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructE::inlineStructT& from) {
  os << "{";
  
os << "\"a\":"; os << from.a();

  os << "}";
}

StructE::inlineStructT StructE::inlineStructT::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructE_inlineStructT(doc);
}


std::string ToJson(const VariantC& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const VariantC& from) {
  os << "{";
  
  if (from.is_inlineStruct()) {
    
if (from.has_inlineStruct()) {os << "\"inlineStruct\":"; ToJson(os, from.inlineStruct());} else {os << "\"inlineStruct\":"; os << "null";}

  }
  
  if (from.is_VariantF()) {
    
if (from.has_VariantF()) {os << "\"VariantF\":"; ToJson(os, from.VariantF());} else {os << "\"VariantF\":"; os << "null";}

  }
  
  if (from.is_vec_a()) {
    
os << "\"vec_a\":";
{
  auto& arr = from.vec_a();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << val;
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}

  }
  
  if (from.is_map_a()) {
    
os << "\"map_a\":";
{
  auto& map = from.map_a();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << escape_json(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  ToJson(os, val);
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}

  }
  
  if (from.is_nestedStructField()) {
    
if (from.has_nestedStructField()) {os << "\"nestedStructField\":"; ToJson(os, from.nestedStructField());} else {os << "\"nestedStructField\":"; os << "null";}

  }
  
  if (from.is_nestedVariantField()) {
    
if (from.has_nestedVariantField()) {os << "\"nestedVariantField\":"; ToJson(os, from.nestedVariantField());} else {os << "\"nestedVariantField\":"; os << "null";}

  }
  
  if (from.is_map_b()) {
    
os << "\"map_b\":";
{
  auto& map = from.map_b();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << std::to_string(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  ToJson(os, val);
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}

  }
  
  if (from.is_vec_b()) {
    
os << "\"vec_b\":";
{
  auto& arr = from.vec_b();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << val;
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}

  }
  
  os << "}";
}


VariantC VariantC::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseVariantC(doc);
}

std::string ToJson(const VariantC::NestedStruct& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const VariantC::NestedStruct& from) {
  os << "{";
  
os << "\"a\":"; os << from.a();

  os << "}";
}

VariantC::NestedStruct VariantC::NestedStruct::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseVariantC_NestedStruct(doc);
}


std::string ToJson(const VariantC::NestedVariant& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const VariantC::NestedVariant& from) {
  os << "{";
  
  if (from.is_a()) {
    
os << "\"a\":"; os << from.a();

  }
  
  os << "}";
}


VariantC::NestedVariant VariantC::NestedVariant::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseVariantC_NestedVariant(doc);
}



std::string ToJson(const VariantC::inlineStructT& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const VariantC::inlineStructT& from) {
  os << "{";
  
os << "\"a\":"; os << from.a();

  os << "}";
}

VariantC::inlineStructT VariantC::inlineStructT::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseVariantC_inlineStructT(doc);
}


std::string ToJson(const VariantC::VariantFT& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const VariantC::VariantFT& from) {
  os << "{";
  
  if (from.is_va()) {
    
os << "\"va\":"; os << from.va();

  }
  
  if (from.is_vb()) {
    
os << "\"vb\":"; os << "\"" << escape_json(from.vb()) << "\"";

  }
  
  os << "}";
}


VariantC::VariantFT VariantC::VariantFT::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseVariantC_VariantFT(doc);
}


// Tmplate function definitions


} // namespace simple_values


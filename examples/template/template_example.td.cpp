
#include "template_example.td.h"

// Generated by the Typedef compiler (EXPERIMENTAL)

#include "rapidjson/document.h"


namespace {

template <typename T>
inline bool IsEmpty(const td::Vector<T>& v) {
  return v.size() == 0;
}


inline std::string escape_json(const std::string& s) {
  std::ostringstream o;
  for (auto c = s.cbegin(); c != s.cend(); c++) {
    switch (*c) {
      case '"': o << "\\\""; break;
      case '\\': o << "\\\\"; break;
      case '\b': o << "\\b"; break;
      case '\f': o << "\\f"; break;
      case '\n': o << "\\n"; break;
      case '\r': o << "\\r"; break;
      case '\t': o << "\\t"; break;
      default:
        if ('\x00' <= *c && *c <= '\x1f') {
          o << "\\u" << std::hex << std::setw(4) << std::setfill('0')
            << static_cast<int>(*c);
        } else {
          o << *c;
        }
    }
  }
  return o.str();
}

inline std::string char32ToJsonString(char32_t c) {
  std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> converter;
  std::string utf8 = converter.to_bytes(&c, &c + 1);
  return escape_json(utf8);
}

inline char32_t GetCharValue(std::string_view str) {
  if (str.size() == 2 && str[0] == '\\') {
    switch (str[1]) {
      case 'n':
        return U'\n';
      case 'r':
        return U'\r';
      case 't':
        return U'\t';
      case '\\':
        return U'\\';
      case '0':
        return U'\0';
      case '\'':
        return U'\'';
      case '\"':
        return U'\"';
    }
  }
  if (str.size() == 4 && str[0] == '\\' && str[1] == 'x') {
    // TODO this seems rather inefficient, do something better?
    std::istringstream ss(std::string(str.substr(2)));
    int value;
    ss >> std::hex >> value;
    return static_cast<char32_t>(value);
  }

  if (str.size() >= 3 && str.size() <= 10 && str[0] == '\\' && str[1] == 'u' &&
      str[2] == '{' && str.back() == '}') {
    // TODO this seems rather inefficient, do something better?
    std::istringstream ss(std::string(str.substr(3, str.size() - 4)));
    int value;
    ss >> std::hex >> value;
    return static_cast<char32_t>(value);
  }

  if (str.size() > 0) {
    std::string inner_str(str);
    std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> converter;
    std::u32string str32 = converter.from_bytes(inner_str);
    if (str32.size() == 1) {
      return str32[0];
    }
  }
  throw std::runtime_error("Invalid char.");
}

// Struct and variant JSON forward declarations

template_example::StructC JsonParseStructC(const rapidjson::Value& obj);

template_example::TemplateData JsonParseTemplateData(const rapidjson::Value& obj);

template_example::SomeVariant JsonParseSomeVariant(const rapidjson::Value& obj);

// Struct and variant JSON definitions

template_example::StructC JsonParseStructC(const rapidjson::Value& obj) {
  template_example::StructC ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("asdf");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsObject()) {
    ret.asdf() = JsonParseTemplateData(val.GetObject());
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("zxcv");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    ret.zxcv() = val.GetInt();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("jkl");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    ret.jkl() = val.GetInt();
  }

  }
  } 
  return ret;
}


template_example::TemplateData JsonParseTemplateData(const rapidjson::Value& obj) {
  template_example::TemplateData ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("name");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsString()) {
    ret.name() = val.GetString();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("has_name");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsBool()) {
    ret.has_name() = val.GetBool();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("name2");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsString()) {
    ret.name2() = val.GetString();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("has_name2");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsBool()) {
    ret.has_name2() = val.GetBool();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("someVec");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsArray()) {
    for (const auto& val : val.GetArray()) {
      // What I really think I want here is to call JsonParseValue
      // with an argument that is a computed assignment target.
      // Eg. ret.someVec() computed from a template function.
//       ret.someVec().emplace_back(std::move(
//       ));
    }
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("someMap");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  // TODO map
  

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("structC");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsObject()) {
    ret.structC() = JsonParseStructC(val.GetObject());
  }

  }
  } 
  return ret;
}


template_example::SomeVariant JsonParseSomeVariant(const rapidjson::Value& obj) {
  template_example::SomeVariant ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a_string");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsString()) {
    ret.a_string() = val.GetString();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("b_int");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    ret.b_int() = val.GetInt();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("c_char");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsString()) {
    std::string str = val.GetString();
    ret.c_char() = GetCharValue(str);
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("d_struct");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsObject()) {
    ret.d_struct() = JsonParseStructC(val.GetObject());
  }

  }
  } 
  return ret;
}


}

namespace template_example {

// Struct and variant definitions

// StructC member definitions

// TemplateData member definitions

// template_example::SomeVariant member definitions

// Struct and variant JSON declarations

std::string ToJson(const StructC& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructC& from) {
  os << "{";
  
if (from.has_asdf()) {os << "\"asdf\":"; ToJson(os, from.asdf());} else {os << "\"asdf\":"; os << "null";}
os << ",";
os << "\"zxcv\":"; os << from.zxcv();
os << ",";
os << "\"jkl\":"; os << from.jkl();

  os << "}";
}

StructC StructC::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructC(doc);
}


std::string ToJson(const TemplateData& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const TemplateData& from) {
  os << "{";
  
os << "\"name\":"; os << "\"" << escape_json(from.name()) << "\"";
os << ",";
os << "\"has_name\":"; os << (from.has_name() ? "true" : "false");
os << ",";
os << "\"name2\":"; os << "\"" << escape_json(from.name2()) << "\"";
os << ",";
os << "\"has_name2\":"; os << (from.has_name2() ? "true" : "false");
os << ",";
os << "\"someVec\":";
{
  auto& arr = from.someVec();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << val;
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}
os << ",";
os << "\"someMap\":";
{
  auto& map = from.someMap();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << escape_json(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  os << "\"" << escape_json(val) << "\"";
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}
os << ",";
if (from.has_structC()) {os << "\"structC\":"; ToJson(os, from.structC());} else {os << "\"structC\":"; os << "null";}

  os << "}";
}

TemplateData TemplateData::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseTemplateData(doc);
}


std::string ToJson(const SomeVariant& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const SomeVariant& from) {
  os << "{";
  
  if (from.is_a_string()) {
    
os << "\"a_string\":"; os << "\"" << escape_json(from.a_string()) << "\"";

  }
  
  if (from.is_b_int()) {
    
os << "\"b_int\":"; os << from.b_int();

  }
  
  if (from.is_c_char()) {
    
os << "\"c_char\":"; os << "\"" << char32ToJsonString(from.c_char()) << "\"";

  }
  
  if (from.is_d_struct()) {
    
if (from.has_d_struct()) {os << "\"d_struct\":"; ToJson(os, from.d_struct());} else {os << "\"d_struct\":"; os << "null";}

  }
  
  os << "}";
}


SomeVariant SomeVariant::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseSomeVariant(doc);
}


// Tmplate function definitions

void PrintStructC(std::ostream& os, const StructC& sc) {
os << "\nStructC contains:\nzxcv: ";
os << sc.zxcv();
os << "\njkl: ";
os << sc.jkl();
os << "\n";

}
void PrintTemplateData(std::ostream& os, const TemplateData& t) {
os << "\n  here's an if:\n  ";
if (t.has_name()) {
os << "\n    yo name: ";
os << t.name();
os << "\n  ";
} else if (t.has_name2()) {
os << "\n    hi name2: ";
os << t.name2();
os << "\n  ";
} else {
os << "\n    neither name or name2.\n  ";
}
os << "\n\n  here's a for statement over a vector:\n  ";


for (size_t td_iter_ = 0; td_iter_ < t.someVec().size(); td_iter_++) {
  auto& i = t.someVec()[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == t.someVec().size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "\n    for value number: ";
os << i;
os << "\n  ";
}

os << "\n\n  here's a for statement over a map:\n  ";


for (auto const& [key, val] : t.someMap()) {
os << "\n    ";
os << key;
os << " -> ";
os << val;
os << "\n  ";
}

os << "\n  Here's structC\n  ";
PrintStructC(os, t.structC());
os << "\n";

}
void DoSomeVariant(std::ostream& os, const SomeVariant& v) {
os << "\n  ";
// Switch v

if (v.is_a_string()) {
os << "It's a string: ";
os << v.a_string();
} else 
if (v.is_b_int()) {
os << "It's an int: ";
os << v.b_int();
} else 
if (v.is_d_struct()) {
os << "It's a struct: ";
PrintStructC(os, v.d_struct());
} else  {
os << "It's the default!";
}
os << "\n";

}
void LoopLogic(std::ostream& os, const td::Vector<std::string>& v) {
os << "\n  LoopLogic:\n  ";


for (size_t td_iter_ = 0; td_iter_ < v.size(); td_iter_++) {
  auto& i = v[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == v.size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "\n  ";
if (IsFirst()) {
os << "\n  This is the first one: ";
os << i;
os << "\n  ";
} else if (IsLast()) {
os << "\n  This is the last one: ";
os << i;
os << "\n  ";
} else {
os << "\n  This is the middle: ";
os << i;
os << "\n  ";
}
os << "\n  ";
}

os << "\n";

}
void BooleanLogic(std::ostream& os, const td::Vector<std::string>& v) {
os << "\n  BooleanLogic:\n  ";


for (size_t td_iter_ = 0; td_iter_ < v.size(); td_iter_++) {
  auto& i = v[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == v.size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "\n  ";
os << i;
os << "\n  ";
if (!IsFirst()) {
os << "This is not the first one.";
} else {
}
os << "\n  ";
if (!IsLast()) {
os << "This is not the last one.";
} else {
}
os << "\n  ";
}

os << "\n";

}
void TestIsEmpty(std::ostream& os, const td::Vector<std::string>& v) {
os << "v is ";
if (!IsEmpty(v)) {
os << " not ";
} else {
}
os << " empty.";

}
void PrintIndices(std::ostream& os, const td::Vector<std::string>& v) {
os << "\n  ";


for (size_t td_iter_ = 0; td_iter_ < v.size(); td_iter_++) {
  auto& i = v[td_iter_];
  auto IsFirst = [&]() { return td_iter_ == 0; };
  auto IsLast = [&]() { return td_iter_ == v.size() - 1; };
  auto Index0 = [&](std::ostream& os) { os << std::to_string(td_iter_); };
  auto Index1 = [&](std::ostream& os) { os << std::to_string(td_iter_ + 1); };
os << "\n  i0: ";
Index0(os);
os << " i1: ";
Index1(os);
os << " \"";
os << i;
os << "\"\n  ";
}

os << "\n  ";
Literal(os);
os << "\n";

}
void Literal(std::ostream& os) {
os << "literal template function.";

}

} // namespace template_example


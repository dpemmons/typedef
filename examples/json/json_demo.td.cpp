
#include "json_demo.td.h"

// Generated by the Typedef compiler (EXPERIMENTAL)

#include "rapidjson/document.h"


namespace {

template <typename T>
inline bool IsEmpty(const td::Vector<T>& v) {
  return v.size() == 0;
}


inline std::string escape_json(const std::string& s) {
  std::ostringstream o;
  for (auto c = s.cbegin(); c != s.cend(); c++) {
    switch (*c) {
      case '"': o << "\\\""; break;
      case '\\': o << "\\\\"; break;
      case '\b': o << "\\b"; break;
      case '\f': o << "\\f"; break;
      case '\n': o << "\\n"; break;
      case '\r': o << "\\r"; break;
      case '\t': o << "\\t"; break;
      default:
        if ('\x00' <= *c && *c <= '\x1f') {
          o << "\\u" << std::hex << std::setw(4) << std::setfill('0')
            << static_cast<int>(*c);
        } else {
          o << *c;
        }
    }
  }
  return o.str();
}

inline std::string char32ToJsonString(char32_t c) {
  std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> converter;
  std::string utf8 = converter.to_bytes(&c, &c + 1);
  return escape_json(utf8);
}

inline char32_t GetCharValue(std::string_view str) {
  if (str.size() == 2 && str[0] == '\\') {
    switch (str[1]) {
      case 'n':
        return U'\n';
      case 'r':
        return U'\r';
      case 't':
        return U'\t';
      case '\\':
        return U'\\';
      case '0':
        return U'\0';
      case '\'':
        return U'\'';
      case '\"':
        return U'\"';
    }
  }
  if (str.size() == 4 && str[0] == '\\' && str[1] == 'x') {
    // TODO this seems rather inefficient, do something better?
    std::istringstream ss(std::string(str.substr(2)));
    int value;
    ss >> std::hex >> value;
    return static_cast<char32_t>(value);
  }

  if (str.size() >= 3 && str.size() <= 10 && str[0] == '\\' && str[1] == 'u' &&
      str[2] == '{' && str.back() == '}') {
    // TODO this seems rather inefficient, do something better?
    std::istringstream ss(std::string(str.substr(3, str.size() - 4)));
    int value;
    ss >> std::hex >> value;
    return static_cast<char32_t>(value);
  }

  if (str.size() > 0) {
    std::string inner_str(str);
    std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> converter;
    std::u32string str32 = converter.from_bytes(inner_str);
    if (str32.size() == 1) {
      return str32[0];
    }
  }
  throw std::runtime_error("Invalid char.");
}

// Struct and variant JSON forward declarations

json_demo::StructA JsonParseStructA(const rapidjson::Value& obj);

json_demo::StructA::NestedStruct JsonParseStructA_NestedStruct(const rapidjson::Value& obj);

json_demo::StructA::NestedVariant JsonParseStructA_NestedVariant(const rapidjson::Value& obj);

json_demo::StructA::inline_structT JsonParseStructA_inline_structT(const rapidjson::Value& obj);

json_demo::StructA::inline_variantT JsonParseStructA_inline_variantT(const rapidjson::Value& obj);

json_demo::StructB JsonParseStructB(const rapidjson::Value& obj);

json_demo::StructB::NestedStruct JsonParseStructB_NestedStruct(const rapidjson::Value& obj);

json_demo::StructC JsonParseStructC(const rapidjson::Value& obj);

json_demo::StructC::NestedStruct JsonParseStructC_NestedStruct(const rapidjson::Value& obj);

json_demo::VariantA JsonParseVariantA(const rapidjson::Value& obj);

// Struct and variant JSON definitions

json_demo::StructA JsonParseStructA(const rapidjson::Value& obj) {
  json_demo::StructA ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_bool");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsBool()) {
    ret.example_bool() = val.GetBool();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_char");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsString()) {
    std::string str = val.GetString();
    ret.example_char() = GetCharValue(str);
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_str");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsString()) {
    ret.example_str() = val.GetString();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_f32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsDouble()) {
    ret.example_f32() = (float)val.GetDouble();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_f64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsDouble()) {
    ret.example_f64() = val.GetDouble();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u8");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsUint()) {
    // TODO bounds check.
    ret.example_u8() = val.GetUint();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u16");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsUint()) {
    // TODO bounds check.
    ret.example_u16() = val.GetUint();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsUint()) {
    ret.example_u32() = val.GetUint();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsUint64()) {
    ret.example_u64() = val.GetUint64();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i8");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    // TODO bounds check
    ret.example_i8() = val.GetInt();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i16");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    // TODO bounds check
    ret.example_i16() = val.GetInt();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    ret.example_i32() = val.GetInt();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt64()) {
    ret.example_i64() = val.GetInt64();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("nested_struct");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsObject()) {
    ret.nested_struct() = JsonParseStructA_NestedStruct(val.GetObject());
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("inline_struct");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsObject()) {
    ret.inline_struct() = JsonParseStructA_inline_structT(val.GetObject());
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("nested_variant");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsObject()) {
    // TODO validate only one.
    ret.nested_variant() = JsonParseStructA_NestedVariant(val.GetObject());
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("inline_variant");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsObject()) {
    // TODO validate only one.
    ret.inline_variant() = JsonParseStructA_inline_variantT(val.GetObject());
  }

  }
  } 
  return ret;
}

json_demo::StructA::NestedStruct JsonParseStructA_NestedStruct(const rapidjson::Value& obj) {
  json_demo::StructA::NestedStruct ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    ret.a() = val.GetInt();
  }

  }
  } 
  return ret;
}


json_demo::StructA::NestedVariant JsonParseStructA_NestedVariant(const rapidjson::Value& obj) {
  json_demo::StructA::NestedVariant ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("c");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    ret.c() = val.GetInt();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("d");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsString()) {
    ret.d() = val.GetString();
  }

  }
  } 
  return ret;
}


json_demo::StructA::inline_structT JsonParseStructA_inline_structT(const rapidjson::Value& obj) {
  json_demo::StructA::inline_structT ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("b");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsString()) {
    ret.b() = val.GetString();
  }

  }
  } 
  return ret;
}


json_demo::StructA::inline_variantT JsonParseStructA_inline_variantT(const rapidjson::Value& obj) {
  json_demo::StructA::inline_variantT ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("e");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    ret.e() = val.GetInt();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("f");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsString()) {
    ret.f() = val.GetString();
  }

  }
  } 
  return ret;
}



json_demo::StructB JsonParseStructB(const rapidjson::Value& obj) {
  json_demo::StructB ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_vec_bool");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsArray()) {
    for (const auto& val : val.GetArray()) {
      // What I really think I want here is to call JsonParseValue
      // with an argument that is a computed assignment target.
      // Eg. ret.example_vec_bool() computed from a template function.
//       ret.example_vec_bool().emplace_back(std::move(
//       ));
    }
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_vec_char");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsArray()) {
    for (const auto& val : val.GetArray()) {
      // What I really think I want here is to call JsonParseValue
      // with an argument that is a computed assignment target.
      // Eg. ret.example_vec_char() computed from a template function.
//       ret.example_vec_char().emplace_back(std::move(
//       ));
    }
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_vec_str");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsArray()) {
    for (const auto& val : val.GetArray()) {
      // What I really think I want here is to call JsonParseValue
      // with an argument that is a computed assignment target.
      // Eg. ret.example_vec_str() computed from a template function.
//       ret.example_vec_str().emplace_back(std::move(
//       ));
    }
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_vec_int");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsArray()) {
    for (const auto& val : val.GetArray()) {
      // What I really think I want here is to call JsonParseValue
      // with an argument that is a computed assignment target.
      // Eg. ret.example_vec_int() computed from a template function.
//       ret.example_vec_int().emplace_back(std::move(
//       ));
    }
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_vec_nested_struct");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsArray()) {
    for (const auto& val : val.GetArray()) {
      // What I really think I want here is to call JsonParseValue
      // with an argument that is a computed assignment target.
      // Eg. ret.example_vec_nested_struct() computed from a template function.
//       ret.example_vec_nested_struct().emplace_back(std::move(
//       ));
    }
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_vec_vec_int");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsArray()) {
    for (const auto& val : val.GetArray()) {
      // What I really think I want here is to call JsonParseValue
      // with an argument that is a computed assignment target.
      // Eg. ret.example_vec_vec_int() computed from a template function.
//       ret.example_vec_vec_int().emplace_back(std::move(
//       ));
    }
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_vec_map_str_int");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsArray()) {
    for (const auto& val : val.GetArray()) {
      // What I really think I want here is to call JsonParseValue
      // with an argument that is a computed assignment target.
      // Eg. ret.example_vec_map_str_int() computed from a template function.
//       ret.example_vec_map_str_int().emplace_back(std::move(
//       ));
    }
  }

  }
  } 
  return ret;
}

json_demo::StructB::NestedStruct JsonParseStructB_NestedStruct(const rapidjson::Value& obj) {
  json_demo::StructB::NestedStruct ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    ret.a() = val.GetInt();
  }

  }
  } 
  return ret;
}



json_demo::StructC JsonParseStructC(const rapidjson::Value& obj) {
  json_demo::StructC ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_map_bool_bool");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  // TODO map
  

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_map_char_char");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  // TODO map
  

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_map_str_str");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  // TODO map
  

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_map_int_int");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  // TODO map
  

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_map_str_nested_struct");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  // TODO map
  

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_map_str_vec");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  // TODO map
  

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_map_str_map");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  // TODO map
  

  }
  } 
  return ret;
}

json_demo::StructC::NestedStruct JsonParseStructC_NestedStruct(const rapidjson::Value& obj) {
  json_demo::StructC::NestedStruct ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("a");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    ret.a() = val.GetInt();
  }

  }
  } 
  return ret;
}



json_demo::VariantA JsonParseVariantA(const rapidjson::Value& obj) {
  json_demo::VariantA ret;
  {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_bool");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsBool()) {
    ret.example_bool() = val.GetBool();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_char");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsString()) {
    std::string str = val.GetString();
    ret.example_char() = GetCharValue(str);
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_str");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsString()) {
    ret.example_str() = val.GetString();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_f32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsDouble()) {
    ret.example_f32() = (float)val.GetDouble();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_f64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsDouble()) {
    ret.example_f64() = val.GetDouble();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u8");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsUint()) {
    // TODO bounds check.
    ret.example_u8() = val.GetUint();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u16");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsUint()) {
    // TODO bounds check.
    ret.example_u16() = val.GetUint();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsUint()) {
    ret.example_u32() = val.GetUint();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_u64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsUint64()) {
    ret.example_u64() = val.GetUint64();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i8");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    // TODO bounds check
    ret.example_i8() = val.GetInt();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i16");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    // TODO bounds check
    ret.example_i16() = val.GetInt();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i32");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt()) {
    ret.example_i32() = val.GetInt();
  }

  }
  } {
  rapidjson::Value::ConstMemberIterator iter = obj.FindMember("example_i64");
  if (iter != obj.MemberEnd()) {
    auto& val = iter->value;
    
  
  if (val.IsInt64()) {
    ret.example_i64() = val.GetInt64();
  }

  }
  } 
  return ret;
}


}

namespace json_demo {

// Struct and variant definitions

// StructA member definitions

// StructB member definitions

// StructC member definitions

// json_demo::VariantA member definitions

// Struct and variant JSON declarations

std::string ToJson(const StructA& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructA& from) {
  os << "{";
  
os << "\"example_bool\":"; os << (from.example_bool() ? "true" : "false");
os << ",";
os << "\"example_char\":"; os << "\"" << char32ToJsonString(from.example_char()) << "\"";
os << ",";
os << "\"example_str\":"; os << "\"" << escape_json(from.example_str()) << "\"";
os << ",";
os << "\"example_f32\":"; os << from.example_f32();
os << ",";
os << "\"example_f64\":"; os << from.example_f64();
os << ",";
os << "\"example_u8\":"; os << (int)from.example_u8();
os << ",";
os << "\"example_u16\":"; os << from.example_u16();
os << ",";
os << "\"example_u32\":"; os << from.example_u32();
os << ",";
os << "\"example_u64\":"; os << from.example_u64();
os << ",";
os << "\"example_i8\":"; os << (int)from.example_i8();
os << ",";
os << "\"example_i16\":"; os << from.example_i16();
os << ",";
os << "\"example_i32\":"; os << from.example_i32();
os << ",";
os << "\"example_i64\":"; os << from.example_i64();
os << ",";
if (from.has_nested_struct()) {os << "\"nested_struct\":"; ToJson(os, from.nested_struct());} else {os << "\"nested_struct\":"; os << "null";}
os << ",";
if (from.has_inline_struct()) {os << "\"inline_struct\":"; ToJson(os, from.inline_struct());} else {os << "\"inline_struct\":"; os << "null";}
os << ",";
if (from.has_nested_variant()) {os << "\"nested_variant\":"; ToJson(os, from.nested_variant());} else {os << "\"nested_variant\":"; os << "null";}
os << ",";
if (from.has_inline_variant()) {os << "\"inline_variant\":"; ToJson(os, from.inline_variant());} else {os << "\"inline_variant\":"; os << "null";}

  os << "}";
}

StructA StructA::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructA(doc);
}

std::string ToJson(const StructA::NestedStruct& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructA::NestedStruct& from) {
  os << "{";
  
os << "\"a\":"; os << from.a();

  os << "}";
}

StructA::NestedStruct StructA::NestedStruct::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructA_NestedStruct(doc);
}


std::string ToJson(const StructA::NestedVariant& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructA::NestedVariant& from) {
  os << "{";
  
  if (from.is_c()) {
    
os << "\"c\":"; os << from.c();

  }
  
  if (from.is_d()) {
    
os << "\"d\":"; os << "\"" << escape_json(from.d()) << "\"";

  }
  
  os << "}";
}


StructA::NestedVariant StructA::NestedVariant::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructA_NestedVariant(doc);
}



std::string ToJson(const StructA::inline_structT& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructA::inline_structT& from) {
  os << "{";
  
os << "\"b\":"; os << "\"" << escape_json(from.b()) << "\"";

  os << "}";
}

StructA::inline_structT StructA::inline_structT::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructA_inline_structT(doc);
}


std::string ToJson(const StructA::inline_variantT& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructA::inline_variantT& from) {
  os << "{";
  
  if (from.is_e()) {
    
os << "\"e\":"; os << from.e();

  }
  
  if (from.is_f()) {
    
os << "\"f\":"; os << "\"" << escape_json(from.f()) << "\"";

  }
  
  os << "}";
}


StructA::inline_variantT StructA::inline_variantT::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructA_inline_variantT(doc);
}


std::string ToJson(const StructB& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructB& from) {
  os << "{";
  
os << "\"example_vec_bool\":";
{
  auto& arr = from.example_vec_bool();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << (val ? "true" : "false");
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}
os << ",";
os << "\"example_vec_char\":";
{
  auto& arr = from.example_vec_char();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << "\"" << char32ToJsonString(val) << "\"";
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}
os << ",";
os << "\"example_vec_str\":";
{
  auto& arr = from.example_vec_str();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << "\"" << escape_json(val) << "\"";
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}
os << ",";
os << "\"example_vec_int\":";
{
  auto& arr = from.example_vec_int();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << val;
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}
os << ",";
os << "\"example_vec_nested_struct\":";
{
  auto& arr = from.example_vec_nested_struct();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  ToJson(os, val);
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}
os << ",";
os << "\"example_vec_vec_int\":";
{
  auto& arr = from.example_vec_vec_int();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  {
    auto& arr = val;
    
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << val;
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

  }
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}
os << ",";
os << "\"example_vec_map_str_int\":";
{
  auto& arr = from.example_vec_map_str_int();
  
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  {
    auto& map = val;
    
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << escape_json(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  os << val;
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

  }
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

}

  os << "}";
}

StructB StructB::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructB(doc);
}

std::string ToJson(const StructB::NestedStruct& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructB::NestedStruct& from) {
  os << "{";
  
os << "\"a\":"; os << from.a();

  os << "}";
}

StructB::NestedStruct StructB::NestedStruct::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructB_NestedStruct(doc);
}



std::string ToJson(const StructC& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructC& from) {
  os << "{";
  
os << "\"example_map_bool_bool\":";
{
  auto& map = from.example_map_bool_bool();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << (key ? "\"true\"" : "\"false\"");
  }
  os << ":";
  {
  const auto& val = iter->second;
  os << (val ? "true" : "false");
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}
os << ",";
os << "\"example_map_char_char\":";
{
  auto& map = from.example_map_char_char();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << char32ToJsonString(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  os << "\"" << char32ToJsonString(val) << "\"";
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}
os << ",";
os << "\"example_map_str_str\":";
{
  auto& map = from.example_map_str_str();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << escape_json(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  os << "\"" << escape_json(val) << "\"";
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}
os << ",";
os << "\"example_map_int_int\":";
{
  auto& map = from.example_map_int_int();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << std::to_string(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  os << val;
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}
os << ",";
os << "\"example_map_str_nested_struct\":";
{
  auto& map = from.example_map_str_nested_struct();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << escape_json(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  ToJson(os, val);
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}
os << ",";
os << "\"example_map_str_vec\":";
{
  auto& map = from.example_map_str_vec();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << escape_json(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  {
    auto& arr = val;
    
os << "[";
for (size_t ii = 0; ii < arr.size(); ii++) {
  const auto& val = arr[ii];
  os << val;
  if (ii < arr.size() - 1) { os << ","; }
}
os << "]";

  }
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}
os << ",";
os << "\"example_map_str_map\":";
{
  auto& map = from.example_map_str_map();
  
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << escape_json(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  {
    auto& map = val;
    
os << "{";
auto iter = map.begin();
while (iter != map.end()) {
  {
  const auto& key = iter->first;
  os << "\"" << escape_json(key) << "\"";
  }
  os << ":";
  {
  const auto& val = iter->second;
  os << val;
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

  }
  }
  ++iter;
  if (iter != map.end()) { os << ","; }
}
os << "}";

}

  os << "}";
}

StructC StructC::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructC(doc);
}

std::string ToJson(const StructC::NestedStruct& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const StructC::NestedStruct& from) {
  os << "{";
  
os << "\"a\":"; os << from.a();

  os << "}";
}

StructC::NestedStruct StructC::NestedStruct::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseStructC_NestedStruct(doc);
}



std::string ToJson(const VariantA& from) {
  std::stringstream ss;
  ToJson(ss, from);
  return ss.str();
}
void ToJson(std::ostream& os, const VariantA& from) {
  os << "{";
  
  if (from.is_example_bool()) {
    
os << "\"example_bool\":"; os << (from.example_bool() ? "true" : "false");

  }
  
  if (from.is_example_char()) {
    
os << "\"example_char\":"; os << "\"" << char32ToJsonString(from.example_char()) << "\"";

  }
  
  if (from.is_example_str()) {
    
os << "\"example_str\":"; os << "\"" << escape_json(from.example_str()) << "\"";

  }
  
  if (from.is_example_f32()) {
    
os << "\"example_f32\":"; os << from.example_f32();

  }
  
  if (from.is_example_f64()) {
    
os << "\"example_f64\":"; os << from.example_f64();

  }
  
  if (from.is_example_u8()) {
    
os << "\"example_u8\":"; os << (int)from.example_u8();

  }
  
  if (from.is_example_u16()) {
    
os << "\"example_u16\":"; os << from.example_u16();

  }
  
  if (from.is_example_u32()) {
    
os << "\"example_u32\":"; os << from.example_u32();

  }
  
  if (from.is_example_u64()) {
    
os << "\"example_u64\":"; os << from.example_u64();

  }
  
  if (from.is_example_i8()) {
    
os << "\"example_i8\":"; os << (int)from.example_i8();

  }
  
  if (from.is_example_i16()) {
    
os << "\"example_i16\":"; os << from.example_i16();

  }
  
  if (from.is_example_i32()) {
    
os << "\"example_i32\":"; os << from.example_i32();

  }
  
  if (from.is_example_i64()) {
    
os << "\"example_i64\":"; os << from.example_i64();

  }
  
  os << "}";
}


VariantA VariantA::FromJson(const std::string& str) {
  rapidjson::Document doc;
  doc.Parse(str.c_str());
  return JsonParseVariantA(doc);
}


// Tmplate function definitions


} // namespace json_demo

